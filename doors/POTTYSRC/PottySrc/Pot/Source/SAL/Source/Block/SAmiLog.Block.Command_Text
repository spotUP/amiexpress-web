*****************************************************************************
* Input for command T(ext):                                                 *
* @Text_Cmd                                                                 *
*****************************************************************************
FTxt_Text
	Cmp.l	d5,a0			End of input?
	Bge	BadInput

	Lea	Text_ProgName_CMD(pc),a2
	Lea	Text_ProgName__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_ProgName	If found, do the command.

	Lea	Text_CoderName_CMD(pc),a2
	Lea	Text_CoderName__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_CoderName	If found, do the command.

	Lea	Text_Copyright_CMD(pc),a2
	Lea	Text_Copyright__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_Copyright	If found, do the command.

	Lea	Text_Release_CMD(pc),a2
	Lea	Text_Release__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_Release		If found, do the command.

	Lea	Text_Version_CMD(pc),a2
	Lea	Text_Version__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_Version		If found, do the command.

	Lea	Text_Random_CMD(pc),a2
	Lea	Text_Random__CMD-1(pc),a3
	Bsr	FTSerch			Search for command...
	Beq	FT_Text_Random		If found, do the command.

	Bra	BadInput

Text_ProgName_CMD	Dc.b	"PROGNAME",0
Text_ProgName__CMD	Dc.b	"progname",0
Text_CoderName_CMD	Dc.b	"CODERNAME",0
Text_CoderName__CMD	Dc.b	"codername",0
Text_Copyright_CMD	Dc.b	"COPYRIGHT",0
Text_Copyright__CMD	Dc.b	"copyright",0
Text_Release_CMD	Dc.b	"RELEASE",0
Text_Release__CMD	Dc.b	"release",0
Text_Version_CMD	Dc.b	"VERSION",0
Text_Version__CMD	Dc.b	"version",0
Text_Random_CMD		Dc.b	"RANDOM",0
Text_Random__CMD	Dc.b	"random",0
			Even

FT_Text_ProgName
	Lea	Creds_1(pc),a2		Point to what to send. (Null Term)
	BSet	#F1_Creds1,Fmt_F_1(a5)
	Bra	FTx_Out
FT_Text_CoderName
	Lea	Creds_2(pc),a2		Point to what to send. (Null Term)
	BSet	#F1_Creds2,Fmt_F_1(a5)
	Bra	FTx_Out
FT_Text_Copyright
	Lea	Creds_3(pc),a2		Point to what to send. (Null Term)
	BSet	#F1_Creds3,Fmt_F_1(a5)
	Bra	FTx_Out
FT_Text_Release
	Lea	Creds_4(pc),a2		Point to what to send. (Null Term)
	BSet	#F1_Creds4,Fmt_F_1(a5)
	Bra	FTx_Out
FT_Text_Version
	Lea	Creds_5(pc),a2		Point to what to send. (Null Term)
	BSet	#F1_Creds4,Fmt_F_1(a5)
	Bra	FTx_Out

Creds_1	Dc.b	"Super-AmiLog",0
Creds_2	Dc.b	"P0T-NOoDLE of Anthrox",0
Creds_3	Dc.b	"(C)1992-4 Gods'Gift",0
Creds_4
	IFND	USUM
	Dc.b	"REL-"
	RELNUMB
	Dc.b	" "
	BETANUM
	ENDC
	IFD	USUM
	Dc.b	"RELEASE "
	RELNUMB
	ENDC
	Dc.b	0
Creds_5	VERSION
	Dc.b	0
	Even
Creds_L	Equ	*-Creds_1		For Checksumming.


NRndTxt	Dc.b	"[Super-AmiLog] = (Speed + Power + Versatility) ; Beware of imitations.",10
LinesFi	Dc.b	"PROGDIR:SAmiLog.Lines",0
	Even

FT_Text_Random
DoRanLi	BSet	#F1_Random,Fmt_F_1(a5)	RndLine will have been selected...
	Bne	RandonLinesEnd		If already got 1, don't load another.
;---------------------------------------------------------------------------;
RAN_MRK	Lea	LinesFi(pc),a0		Randomlines filename
	Move.l	a0,FileNam(a5)		For NRead4 below.
	Lea	RND_NOT_RT(pc),a0	-._ If the file doesn't exist
	Move.l	a0,NoFilRt(a5)		-'  jump to RND_NOT
	Bsr	NRead4			Continue read as normal
;===========================================================================;
	Move.l	FileAdr(a5),a0		Point to File
	Move.l	a0,a2			-._ Find adr of end of file
	Add.l	FileSze(a5),a2		-'  for Search routine.
	Moveq	#0,d5			Clear d0 to count number of returns
	Moveq	#10,d1			<Return> for speed.

RetLoop	Cmp.l	a2,a0			Are we at/past the EOF?
	Bge.s	CtdRet			YES=All returns counted...
	Cmp.b	(a0)+,d1		Is this a return?
	Bne.s	RetLoop			Nope, Look at next character
	Addq.l	#1,d5			Yes, 1 more return found...
	Bra.s	RetLoop			...Look for more

CtdRet	Tst.l	d5			-._ If NO returns found,
	Beq	InvRND			-'  Error In RNDLines file...
	Cmpi.l	#$FFFF,d5		More than $FFFF lines?
	Blt.s	DoneRet
	Move.l	#$FFFF,d5		Yes = Set to $FFFF lines
DoneRet
;	NOW The number of lines (#rets) is in d5
;===========================================================================;
	Bsr	RndWord			Get #Rnd 0 to (d5-1) (NumLins) » d3
;;;;;;; This is fine as the returned number will be how many returns to FIND
;;;;;;; (ie the line_number-1 - so for Line 1, d3=0 !)
LinSel	Move.l	FileAdr(a5),a0		Point to Start of random lines
	Moveq	#10,d0			<Return> for speed.
	Bra.s	RetSelJ			Goto Line #d3 (count starts at 0!)
RetLoo2	Cmp.b	(a0)+,d0		Is this a return?
	Bne.s	RetLoo2			Nope, Keep looking...
RetSelJ	DBra	d3,RetLoo2		Yup, Keep looking till all returns found
;---------------------------------------------------------------------------;
	Bra.s	LinGet
RND_NOT_RT
	Addq.l	#4,SP			Compensate for RTS
	Lea	NRndTxt(pc),a0		No RND Lines file, so use the default.

;					Now a0 points to START of line to use.
;					We wanna find its length!
LinGet	Move.l	a0,a1			Preserve a0
	Moveq	#-1,d3			Clear d3 for Adding to (-1 for below)
	Moveq	#10,d0			<Return> for speed.
LinLoop	Addq.l	#1,d3			Add one to length of line...
	Cmp.b	(a1)+,d0		Is this the return?
	Bne.s	LinLoop			Keep adding to lenght till return found
LinDone	Cmpi.l	#RndMax,d3		Is the line over 75 chars?
	Ble.s	LinGet2
	Moveq	#RndMax,d3		Yes=Truncate line length
LinGet2	Moveq	#RndMax,d2
	Sub.l	d3,d2			How shorter than 75 chars is the line?
	Asr.l	#1,d2			Number of spaces for LEFT side. (div2)
	Lea	RanSpac(a5),a1
	Add.l	d2,a1			Point past spaced letters
	Bra.s	LinLo2J
LinLoo2	Move.b	(a0)+,(a1)+		Move letter from Lines into Store.
LinLo2J	Dbra	d3,LinLoo2		Keep on till no more letters.
;===========================================================================;
	Bsr	FilDAlo			Deallocate mem used for RndLines File
RandonLinesEnd
	Move.l	FTInptAdr(a5),a0	Restore adr start of input
	Lea	RanSpac(a5),a2		What to write...
	Move.w	RndLen(a5),d2		Length to write...
	And.l	#$FFFF,d2
	Move.l	d2,d3
	Sub.l	#RndMax,d3		Diff line length and length wanted.
	Bge.s	RndLarg			If NOT a neg result, too long a
;;;;;;;					string requested, just output maxlen.
	Asr.l	#1,d3			Div by 2, find indent length.
	Addq.l	#1,d3
	Sub.l	d3,a2			Indent pointer [ SUB coz -(-x) = +x ]
RndLarg	Bra	FTxLOut			Output the line itself!
