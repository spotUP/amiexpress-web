*****************************************************************************
* Option U - Update Storage File                                            *
*****************************************************************************
U_ClgT	Dc.b	"Working on new Caller",10
U_ClgTL	Equ	*-U_ClgT
	Even

OppyU	Tst.l	Update_N(a5)		Was Update argument given?
	Bne.s	OppyUDo
	RTS				If not, return.

OppyUDo	Move.b	#0,Opt_F_1(a5)		Clear Options
	Bsr	BigDAlo			De-Alocate Any Files In Memory

	BSet	#X1_AnyRout,Fil_F_1(a5)	Signal that a routine has been run.
	Lea	U_ClgT(pc),a0		-.
	Moveq	#U_ClgTL,d3		 |_ Progress
	Bsr	CLIRite			 |  Text
	Bsr	CkCtrlC			-'

	Move.l	Update_N(a5),a1
	Move.l	(a1),d1
	Cmpi.l	#99,d1			-.
	Bgt	Do0CNod			 |_ Make sure not -ve or
	Tst.l	d1			 |  over 99.
	Blt	Do0CNod			-'
	Lea	StdBuff(a5),a1
	Bsr	N2A2Dig			Convert node number to ASCII.
	Lea	StdBuff(a5),a0

	Move.l	Update_N(a5),a1		MUST be a1 for later...
	Cmpi.l	#10,(a1)		Two digit node number?
	Blt.s	Do1CNod

Do2CNod	Move.b	(a0),Clog+8(a5)		-._ Write 2 digit node number
	Move.b	1(a0),Clog+9(a5)	-'  into callerslog path.

	Move.b	(a0),NUS+SU_Node2(a5)	Write 2 digit node number for user.
	Move.b	1(a0),NUS+SU_Node2+1(a5)

	Move.l	(a1),d0
	Add.l	#65-10,d0		- 1st digit = #10, "A" = #65
	Move.b	d0,NUS+SU_Node(a5)	Write User's 1 digit node Number

	Bra.s	DonCNod
Do1CNod	Move.b	1(a0),Clog+8(a5)	Overlay Node# on Callerslog Path.
	Move.b	1(a0),NUS+SU_Node(a5)	Write User's node Number
	Move.b	#" ",NUS+SU_Node2(a5)	Space for 1st digit,
	Move.b	1(a0),NUS+SU_Node2+1(a5)	Node for second.
	Lea	Clog+9(a5),a1		Point to where 2nd node digit WOULD B
	Lea	Clog+10(a5),a0
Do1Loop	Move.b	(a0)+,(a1)+		Shift the path allong for 1 digit.
	Bne.s	Do1Loop
DonCNod
*******************************************************************************
	Bsr	LoadSto			Load Storage File into memory
*******************************************************************************
* Load Callerslog Into Memory                                                 *
*******************************************************************************
ClReadSze	=	51200
; = 50kbytes
; Cannot be larger than $FFFF

	Lea	Clog(a5),a0		Point to Callerslog Filename.
	Move.l	#ClReadSze,Temp002(a5)	Read this many bytes from the EOF.
	Bsr	ReadSo3			Read the callerslog into memory
*******************************************************************************	
* Callerslog is now in Memory! Lets do the stuff..                            *
*******************************************************************************
	Move.l	FileAdr(a5),a0		Point to Callerslog in Memory
	Move.l	a0,d6			Adr Start into d6.
	Add.l	FileSze(a5),a0		Point to End of Callerslog
	Move.l	a0,EndRef(a5)		Store this possition.

	Move.b	#"*",d0			Into reg for speed.
GetStSt	Moveq	#39,d2			Reset number to find...
GetStar	Cmp.l	d6,a0			Compare Start Adr with Current Adr.
	Ble	InvCLog			If at or before start, invalid clog.
	Cmp.b	-(a0),d0		Is this char a "*"?
	DBne	d2,GetStar		Find all 40 of 'em.
	Bne.s	GetStSt			If it WASN'T a star, reset count.

GotStar	Move.l	EndRef(a5),d6		Moving forwards, checking for END.
;=============================================================================;
; Now to get the info we want from the Callerslog                             ;
;=============================================================================;
;("SF <?>" is same as a "Move.b #0,<?>" but quicker)
	SF	NUS+SU_Flag_1(a5)	Clear All flags for new user's info.
	SF	NUS+SU_Flag_2(a5)	Ditto
;;;;;;;	SF	NUS+SU_Flag_3(a5)	(Unused)
	Move.l	#0,TotlCPS(a5)		Reset sum of user's cps rates.
	Move.l	#0,NumbCPS(a5)		Reset number of CPS rates in sum


	Lea	41(a0),a0		Start of Date String/
	Sub.l	#30,d6			Reading upto 30chars ahead...
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.
	Add.l	#30,d6

	Cmpi.b	#"-",2(a0)		-.
	Bne	InvCLog			 |_ Make sure this
	Cmpi.b	#"-",5(a0)		 |  is a date string.
	Bne	InvCLog			-'

	Moveq	#2,d2			Converting 2 Digit Number
	Bsr	Asc2Num			Convert Month-Ascii » #(d0)
	Cmpi.l	#12,d0			-._ If a month past December,
	Bgt	InvCLog			-'  date and callerslog invalid.
	Muls.w	#4,d0			Multiply Month# by Length of MonthStr
	Lea	Months-4(pc),a1		-._ Now Pointing to the month
;;;;;;;	Add.l	d0,a1			-'  The Required Month String
	Move.l	(a1,d0),NUS+SU_OnDate+3(a5)	Move the required month in.

	Move.b	1(a0),NUS+SU_OnDate+0(a5)	-._ Copy the Day
	Move.b	2(a0),NUS+SU_OnDate+1(a5)	-'  into Temp User Structure.
	Move.b	4(a0),NUS+SU_OnDate+7(a5)	-._ Copy the Year
	Move.b	5(a0),NUS+SU_OnDate+8(a5)	-'  into Temp User Structure.

	Cmpi.b	#":",10(a0)			-.
	Bne	InvCLog				 |_ Check that this is
	Cmpi.b	#":",13(a0)			 |  a time string!
	Bne	InvCLog				-'
	Move.b	8(a0),NUS+SU_OnTime(a5)	-.
	Move.b	9(a0),NUS+SU_OnTime+1(a5)	 |
;;;;;;;	Move.b	#":",NUS+SU_OnTime+2(a5)	 |
	Move.b	11(a0),NUS+SU_OnTime+3(a5)	 |_ Store Logon Time
	Move.b	12(a0),NUS+SU_OnTime+4(a5)	 |  (":"'s moved)
;;;;;;;	Move.b	#":",NUS+SU_OnTime+5(a5)	 |
	Move.b	14(a0),NUS+SU_OnTime+6(a5)	 |
	Move.b	15(a0),NUS+SU_OnTime+7(a5)	-'
;=============================================================================;
	Lea	18(a0),a0		Point to where "[###] / NEW" should be

	BClr	#SU_F1_New,NUS+SU_Flag_1(a5)	NewFlag off.
	Move.b	#"[",d0
	Cmp.b	(a0),d0			Is it [NUM]??
	Beq.s	NoNu			Yes, Not a new user.
	Bset	#SU_F1_New,NUS+SU_Flag_1(a5)	Else, NewFlag on.
	Bsr	SAdrByt			Forward to the "["
	Add.l	d3,a0			Point to it.
;;;;;;;	Cmp.l	d6,a0			-._ If past the end,
;;;;;;; ...	...			Check done below!

;					At NoNu We'll Always be at the [NUM]
NoNu	Tst.l	NoSysop_S(a5)		Was NoSysop Switch given?
	Beq.s	NoOpS			If not, don't check the usernum.
YoOpS	Subq.l	#2,d6			Going 2 chars past a0...
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.
	Addq.l	#2,d6			No longer 2 chars past a0...

	Cmpi.b	#"1",1(a0)		Is it a sysop login?? (User #1)
	Bne.s	NoOpS
	Cmpi.b	#"]",2(a0)
	Bne.s	NoOpS
	RTS				If it IS the sysop, skip update cmd.

NoOpS	Move.b	#"]",d0
	Bsr	SAdrByt			Forward to the "]"
	Add.l	d3,a0			Point to it.
;=============================================================================;
Namer	Addq.l	#1,a0			Point to Start of username.
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

; a0/d6 already setup, a0|2/d6 preserved by SAdrStr routine.
	Lea	ConStri(pc),a2		Point to " (CONNECT " for compair.
	Bsr	SAdrStr			Get Distance to " (CONNECT " into d3
	Cmpi.l	#-1,d3			Did SEARCH find it??
	Bne.s	NamFin2			Yes continue...

	Lea	SysStri(pc),a2		Point to " (SYSOP_LO" for compair
	Bsr	SAdrStr			Get distance to it
	Cmpi.l	#-1,d3			Did it find it?
	Bne.s	NamFin2			Yes continue...

	Lea	LocStri(pc),a2		Point to " (F2_LOCAL" for compair
	Bsr	SAdrStr			Get distance to it
	Cmpi.l	#-1,d3			Did SEARCH fint it??
	Bne.s	NamFin2			Yes continue...
	Bra	Locatio			NO= Don't write username or Baud.
ConStri	Dc.b	" (CONNECT ",0		Normal connect.
LocStri	Dc.b	" (F2_LOCAL",0		Local "connect".
SysStri	Dc.b	" (SYSOP_LO",0		Local-sysop "connect".
	Even
NamFin2	Movem.l	d3/d6/a0,-(SP)		Preserve a0/d3/d6
	Lea	NUS+SU_Name(a5),a1	Overlay into Username space
	Moveq	#SU_Name_Len,d1		Which is this long
	;				a0 Points to Username, d3 it's length
	Bsr	SpaOver			Overlay name, space pad.
	Movem.l	(SP)+,d3/d6/a0		Restore a0/d3/d6
;===========================================================================;
GetBaud	Add.l	d3,a0			Point to start of connect string.
	Addq.l	#1,a0			Point past the space.
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

;;;;;;;	SAdrByt routine takes a0/d6 for search area and preserves them.
	Move.b	#")",d0			-.
	Bsr	SAdrByt			 |_ Make sure that there's a ")"
	Cmpi.l	#-1,d3			 |  before the end of the file.
	Beq	InvCLog			-'  Else the CLog is invalid.
	Move.b	#" ",d0			-.
	Move.b	#")",d1			 |  Make sure that there's a " "
	Bsr	SR_Eith			 |- before the end of the connect str. 
	Beq.s	UGBJmp1			-'  Else the call is LOCAL.
	BSet	#SU_F1_Locl,NUS+SU_Flag_1(a5)	Set Local Call Bit in Storage.
	Bra.s	GotBaud			Skip Baud Rate Fetch.
UGBJmp1	Addq.l	#1,d3			-._ Point to the Baud Rate
	Add.l	d3,a0			-'  with a0
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

	Moveq.l	#")",d0			-.  Get distance to EITHER a "/" or
	Moveq.l	#"/",d0			 |- a ")" (To the end of the Baud)
	Bsr	SR_Eith			-'  Into d3.

	Moveq	#5,d0
	Sub.l	d3,d0			How many LESS than 5 chars is baud?
	Bmi.s	GotBaud			Baud MORE than 5 = skip getting it.

	Lea	NUS+SU_Baud(a5),a1	Point to Place to put the baud rate.
	Bra.s	UGBJmp2			-.
UGBLop1	Move.b	#" ",(a1)+		 |- Write spaces to compensate length.
UGBJmp2	DBra	d0,UGBLop1		-'

	Move.l	d3,d7
	Sub.l	d7,d6			Checking d7 chars outside of a0
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

	Cmpi.b	#"6",(a0)			-.
	Bne.s	UGBJmp3				 |
	Cmpi.b	#"4",1(a0)			 |
	Bne.s	UGBJmp3				 |
	Cmpi.b	#"0",2(a0)			 |  If 64000 baud, set
	Bne.s	UGBJmp3				 |- ISDN call flag
	Cmpi.b	#"0",3(a0)			 |  in user-storage.
	Bne.s	UGBJmp3				 |
	Cmpi.b	#"0",4(a0)			 |
	Bne.s	UGBJmp3				 |
	BSet	#SU_F1_ISDN,NUS+SU_Flag_1(a5)	-'
	Bra.s	UGBJmp3			-.
UGBLop2	Move.b	(a0)+,(a1)+		 |- Write the Baud Rate itself.
UGBJmp3	DBra	d3,UGBLop2		-'
	Add.l	d7,d6			Reset to 0 chars outside a0.
GotBaud
;=============================================================================;
Locatio	Move.b	#")",d0			-.
	Bsr	SAdrByt			 |_ Make sure that there's a ")"
	Cmpi.l	#-1,d3			 |  before the end of the file.
	Beq	InvCLog			-'  Else the CLog is invalid.

	Addq.l	#1,d3			Point past the space...
	Add.l	d3,a0			Point to Start of Location.
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

;;;;;;;	SAdrByt routine takes a0/d6 for search area and preserves them.
	Move.b	#10,d0			-.  Find how far it is to the EOL
	Bsr	SAdrByt			 |_ <return>. To work out the length
	Cmpi.l	#-1,d3			 |  of the user's location.
	Beq	InvCLog			-'  Not found=the CLog is invalid.

LocOvP
;;;;;;;					a0 already points to location.
	Subq.l	#1,d3			Correct (a1)+ (NOT SURE IF NEEDED WITH SRBytFw)
	Lea	NUS+SU_Location(a5),a1	Point to Area to Overlay into
	Moveq.l	#SU_Location_Len,d1	Which is 19 Chars
	Bsr	SpaOver			Overlay location!
;=============================================================================;
	Bra.s	LOTime
OffBck	Dc.b	" ffO",0		"Off " for backward search.
	Even
LOTime	Move.l	a0,StarRef(a5)		For future reference to start.
;;;;;;;	...	...			as this is start of usefull stuff.

	Move.l	a0,d6			Searching etc ends at TOP of file.
	Move.l	EndRef(a5),a0		Point to END of file.

; SBaStAd routine uses a0/d6 as area to search (already set) & preserves 'em
	Lea	OffBck(pc),a2		"Off " (Backwards) string to search for
	Bsr	SBaStAd			Search backwards for "Off ".
	Cmpi.l	#-1,d3			-._ If not found,
	Beq	UPFilez			-'  don't get logoff time.
	Sub.l	d3,a0			Point to the line with logoff time.
;;;;;;;	No need to check for start of file, coz it WAS found!
	Move.b	#10,d0			Find a return...
	Bsr	SBAdByt
	Cmpi.l	#-1,d3			-._ None found,
	Beq	InvCLog			-'  invalid Callerslog..
	Sub.l	d3,a0			Point to start of logoff line.

	Move.l	EndRef(a5),d6		Moving forwards, check for end.
	Sub.l	#19,d6			Checking 18 chars past a0.
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.
	Add.l	#19,d6

OTimmy	Cmpi.b	#":",13(a0)		-.
	Bne	UPFilez			 |_ Make sure this is a
	Cmpi.b	#":",16(a0)		 |  time string...
	Bne.s	UPFilez			-'
	Move.b	11(a0),NUS+SU_OffTime(a5)	-.
	Move.b	12(a0),NUS+SU_OffTime+1(a5)	 |
;;;;;;;	Move.b	#":",NUS+SU_OffTime+2(a5)	 |
	Move.b	14(a0),NUS+SU_OffTime+3(a5)	 |_ Store Logoff Time
	Move.b	15(a0),NUS+SU_OffTime+4(a5)	 |  (":"s not copied)
;;;;;;;	Move.b	#":",NUS+SU_OffTime+5(a5)	 |
	Move.b	17(a0),NUS+SU_OffTime+6(a5)	 |
	Move.b	18(a0),NUS+SU_OffTime+7(a5)	-'
UUsdTim	Lea	NUS+SU_OffTime(a5),a0	Point to Logoff Time...
	Bsr	Hrs2Min			Work out Logoff Time in Mins.
	Move.l	d0,d4			Preserve d0.
	Lea	NUS+SU_OnTime(a5),a0	Point to logon time.
	Bsr	Hrs2Min			LogonMin=d0, LogoffMin=d4

	Move.l	d0,OnMins(a5)		Store mins of logon time.

	Cmp.l	d4,d0
	Ble.s	NoNewDa			Logoff after/same as logon. Normal.
	Add.l	#1440,d4		Add 24*60 mins coz logoff on new day.

NoNewDa	Sub.l	d0,d4			Difference in mins of Logon/Off Time
	Move.l	d4,Usage(a5)		Store it for later.
	Moveq	#0,d0			Clear d0 for .w move
	Moveq	#0,d1			Clear d1 for .w move
	Divu.w	#60,d4			Find Number of Hours.
	Add.b	#$30,d4			Number » Ascii
	Move.b	d4,NUS+SU_Usage(a5)	Overlay number of hours.
	And.l	#$FFFF0000,d4		Clear Lower Word
	Swap	d4			Swap D4 to get remainder (Mins)
	Divu.w	#10,d4			How many ten mins?
	Add.b	#$30,d4			Number » Ascii
	Move.b	d4,NUS+SU_Usage+2(a5)	Overlay number of 10mins.
	Swap	d4			Swap to get remainder (1 Mins)
	Add.b	#$30,d4			Number » Ascii
	Move.b	d4,NUS+SU_Usage+3(a5)	Overlay number of mins.
;===========================================================================;
UPFilez	Lea	UpFile(pc),a0		Searching for " file(s), " (Uploads)
	Move.l	a0,Temp001(a5)		For the Subroutine to use.

	Lea	UpFiles(a5),a0		Get address of number of uploads.
	Move.w	#0,(a0)			Clear it.
	Move.l	a0,Temp002(a5)		For the Subroutine to use.

	Lea	UpBytes(a5),a0		Get address of number of uploaded bytes
	Move.l	#0,(a0)			Clear it.
	Move.l	a0,Temp003(a5)		For the subroutine to use.

	Lea	NUS+SU_UpKBytes(a5),a0	Point to Space for ASCII UploadBytes
	Move.l	a0,Temp004(a5)		For the subroutine to use.

	Lea	NUS+SU_UpFiles(a5),a0	Point to Space for ASCII UploadFiles
	Move.l	a0,Temp005(a5)		For the subroutine to use.

	BClr	#SC_F1_UpDn,NCP_F_1(a5)	Set to UPLOAD for TopCPS

	Bsr	UPDNInf			Get & Store information about UPLOADS
;=============================================================================;
DNFilez	Lea	DnFile(pc),a0		Searching for " files, " (Downloads)
	Move.l	a0,Temp001(a5)		For the Subroutine to use.

	Lea	DnFiles(a5),a0		Get address of number of downlaods.
	Move.w	#0,(a0)			Clear it.
	Move.l	a0,Temp002(a5)		For the Subroutine to use.

	Lea	DnBytes(a5),a0		Get address of number of dnloaded bytes
	Move.l	#0,(a0)			Clear it.
	Move.l	a0,Temp003(a5)		For the subroutine to use.

	Lea	NUS+SU_DnKBytes(a5),a0	Point to Space for his downloads
	Move.l	a0,Temp004(a5)		For the subroutine to use.

	Lea	NUS+SU_DnFiles(a5),a0	Point to Space for ASCII UploadFiles
	Move.l	a0,Temp005(a5)		For the subroutine to use.

	BSet	#SC_F1_UpDn,NCP_F_1(a5)	Set to DOWNLOAD for TopCPS

	Bsr	UPDNInf			Get & Store information about DNLOADS
;---------------------------------------------------------------------------;
	Move.l	TotlCPS(a5),d1		Get the sum of user's CPS rates.
	Move.l	NumbCPS(a5),d0		Get number of CPS rates in sum...
	Tst.w	d0			-._ If 0 cps scores, leave average
	Beq.s	NorACPS			-'  as 0 and avoid a divide by zero.
	Divs.w	d0,d1			d0.l / d1.w = d0.w (GET AVERAGE)
	And.l	#$FFFF,d1		Clear remainder.
	Cmpi.w	#9999,d1		Over 9999?
	Ble.s	NorACPS			NO = Convert it as normal...
	Move.l	#"FAST",NUS+SU_AvCPS(a5)	ELSE, cop out!
	Bra.s	DonACPS
NorACPS	Lea	NUS+SU_AvCPS(a5),a1
	Bsr	N2A4Dig			Write 4 digit # into struc.

	Lea	NUS+SU_AvCPS(a5),a1
	Moveq	#3,d1			4 digit #. (only do 3)
	Bsr	NoZero			Remove Zeros.
DonACPS
;===========================================================================;
Actions	Move.l	StarRef(a5),a0		Point to start of log. search
	Move.l	EndRef(a5),d6		Going forwards, end at end of file.
ActPWH	Lea	Act1(pc),a2		Searching for Action-1 "Password Fail"
	Bsr	SAdrStr			Find it.
	Cmpi.l	#-1,d3				-.
	Beq.s	ActPWHD				 |- If found, set action bit.
	Bset	#SU_F1_Hack,NUS+SU_Flag_1(a5)	-'
ActPWHD
ActDrp	Lea	Act2(pc),a2		"Off Loss Carrier"
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActDrpD
	Bset	#SU_F1_Drop,NUS+SU_Flag_1(a5)
ActDrpD
ActOpP	Move.w	#0,Pages(a5)		Clear Total (Not needed, but in case)
	Lea	Act3(pc),a2		"Operator Paged"
ActPJmp	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActOpPD
	Bset	#SU_F1_Page,NUS+SU_Flag_1(a5)
	Addq.w	#1,Pages(a5)
	Add.l	d3,a0
	Addq.l	#1,a0			Point Past it!
	Bra.s	ActPJmp
ActOpPD	Move.l	StarRef(a5),a0		Reset searching from TOP.
;------
ActDnF	Lea	Act5(pc),a2		"Download Failed"
ActDJmp	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActDnFD
	Bset	#SU_F2_Dnld,NUS+SU_Flag_2(a5)
	Bset	#SU_F2_DnFl,NUS+SU_Flag_2(a5)
	Add.l	d3,a0
	Addq.l	#1,a0			Point Past it!
	Bra.s	ActDJmp
ActDnFD	;	Now a0 is pointing to the LAST found "Download Failed" (if
	;	none found, it's still at the top). If a successfull download
	;	is found after the LAST failed one, the Fail flag is cleared.
ActDnl	Lea	Act4(pc),a2		"Downloading"
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActDnlD
	Bset	#SU_F2_Dnld,NUS+SU_Flag_2(a5)
	Bclr	#SU_F2_DnFl,NUS+SU_Flag_2(a5)
ActDnlD	Move.l	StarRef(a5),a0		Reset searching from TOP.
;------
ActUpF	Lea	Act7(pc),a2		"Upload Failed"
ActUJmp	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActUpFD
	Bset	#SU_F2_UpFl,NUS+SU_Flag_2(a5)
	Bset	#SU_F2_Upld,NUS+SU_Flag_2(a5)
	Add.l	d3,a0
	Addq.l	#1,a0			Point Past it!
	Bra.s	ActUJmp
ActUpFD	;	Now a0 is pointing to the LAST found "Upload Failed" (if
	;	none found, it's still at the top). If a successfull upload
	;	is found after the LAST failed one, the Fail flag is cleared.
ActUpl	Lea	Act6a(pc),a2		"Uploading"
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Bne.s	ActUplY
	Lea	Act6b(pc),a2		"Resuming"
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq.s	ActUplD
ActUplY	Bset	#SU_F2_Upld,NUS+SU_Flag_2(a5)
	Bclr	#SU_F2_UpFl,NUS+SU_Flag_2(a5)
ActUplD	Move.l	StarRef(a5),a0		Reset searching from TOP.
;------
ActSys	Lea	Act8a(pc),a2		If it finds 8(a/b/c) itll set the bit.
	Bsr	SAdrStr			"SYSOP DOWNLOAD:"
	Cmpi.l	#-1,d3			"Account Edit"
	Bne.s	ActSysY			"SysopView"
	Lea	Act8b(pc),a2
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Bne.s	ActSysY
	Lea	Act8c(pc),a2
	Bsr	SAdrStr
	Cmpi.l	#-1,d3
	Beq	ActSysD
ActSysY	Bset	#SU_F1_SysC,NUS+SU_Flag_1(a5)
	Bra	ActSysD
Act1	Dc.b	"Password Failure",0
Act2	Dc.b	"Off Loss Carrier",0
Act3	Dc.b	"Operator Paged",0
Act4	Dc.b	"Downloading",0
Act5	Dc.b	"Download Failed",0
Act6a	Dc.b	"Uploading",0
Act6b	Dc.b	"Resuming",0
Act7	Dc.b	"Upload Failed",0
Act8a	Dc.b	"SYSOP DOWNLOAD:",0
Act8b	Dc.b	"Account edit",0
Act8c	Dc.b	"SysopView",0
;*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*;
* The new user has been built. Now it's time to update the storage file     *
;*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*;
;---------------------------------------------------------------------------;
U_StoT	Dc.b	"Update: Updating Storage File",10
U_StoTL	Equ	*-U_StoT
	Even
;---------------------------------------------------------------------------;
ReDCopy	Lea	SD_DayName+SD0_Base(a5),a0
	Move.b	(a0)+,(a1)+
	Move.b	(a0)+,(a1)+
	Move.b	(a0)+,(a1)+
	Move.b	#",",(a1)+
	Move.b	#" ",(a1)+
	Lea	SD_AsciiDate+SD0_Base(a5),a0
	Moveq	#8,d7			...copy 9 letters...
ADCCLRC	Move.b	(a0)+,(a1)+
	DBra	d7,ADCCLRC
	SF	(a1)+			Ensure it's null-terminated.
	RTS
;---------------------------------------------------------------------------;
ActSysD	Bsr	FilDAlo			Deallocate mem for callerslog.
	Lea	U_StoT(pc),a0		-.
	Moveq	#U_StoTL,d3		 |_ Progress
	Bsr	CLIRite			 |  Text.
	Bsr	CkCtrlC			-'

	Bsr	FilInD8			Fill in date strings & DT_Days(a5)

	Tst.l	SD_Date+SD0_Base(a5)	Is this a new Storage File?
	Beq.s	Clear			Yup! Initilize Storage File.

NotOne	Move.l	SD_Date+SD0_Base(a5),d7	Put Day0's Date into d7
	Cmp.l	DT_Days(a5),d7		Compare it to Today's date.
	Bge	NoClear			If Day0's date is greater than/equal
	;				to Today's, don't clear storage.

Clear	BSet	#U1_NewDay,Opt_F_1(a5)	Next routines will know about new day
;---------------------------------------------------------------------------;
; Update Records - Check if any were broken. If so write new record & date  ;
;---------------------------------------------------------------------------;
UR_Call	Move.w	SD_Calls+SD0_Base(a5),d0
	Cmp.w	SR_Calls(a5),d0
	Ble.s	UR_Call_Done			Branch if record not broken
	Move.w	d0,SR_Calls(a5)			Store Record
	Lea	SR_Calls_D(a5),a1		Store Date.
	Bsr.s	ReDCopy
UR_Call_Done
UR_UpKB	Move.l	SD_UpKBytes+SD0_Base(a5),d0
	Cmp.l	SR_UpKBytes(a5),d0
	Ble.s	UR_UpKB_Done			Branch if record not broken
	Move.l	d0,SR_UpKBytes(a5)		Store Record
	Lea	SR_UpKBytes_D(a5),a1		Store Date.
	Bsr.s	ReDCopy
UR_UpKB_Done
UR_UpFl	Move.w	SD_UpFiles+SD0_Base(a5),d0
	Cmp.w	SR_UpFiles(a5),d0
	Ble.s	UR_UpFl_Done			Branch if record not broken
	Move.w	d0,SR_UpFiles(a5)		Store Record
	Lea	SR_UpFiles_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_UpFl_Done
UR_DnKB	Move.l	SD_DnKBytes+SD0_Base(a5),d0
	Cmp.l	SR_DnKBytes(a5),d0
	Ble.s	UR_DnKB_Done			Branch if record not broken
	Move.l	d0,SR_DnKBytes(a5)		Store Record
	Lea	SR_DnKBytes_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_DnKB_Done
UR_DnFl	Move.w	SD_DnFiles+SD0_Base(a5),d0
	Cmp.w	SR_DnFiles(a5),d0
	Ble.s	UR_DnFl_Done			Branch if record not broken
	Move.w	d0,SR_DnFiles(a5)		Store Record
	Lea	SR_DnFiles_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_DnFl_Done
UR_Hour	Move.l	SD_UsedMins+SD0_Base(a5),d0
	Cmp.l	SR_UsedMins(a5),d0
	Ble.s	UR_Hour_Done			Branch if record not broken
	Move.l	d0,SR_UsedMins(a5)		Store Record
	Lea	SR_UsedMins_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_Hour_Done
UR_News	Move.w	SD_NewUsers+SD0_Base(a5),d0
	Cmp.w	SR_NewUsers(a5),d0
	Ble.s	UR_News_Done			Branch if record not broken
	Move.w	d0,SR_NewUsers(a5)		Store Record
	Lea	SR_NewUsers_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_News_Done
UR_Hack	Move.w	SD_Hacks+SD0_Base(a5),d0
	Cmp.w	SR_Hacks(a5),d0
	Ble.s	UR_Hack_Done			Branch if record not broken
	Move.w	d0,SR_Hacks(a5)			Store Record
	Lea	SR_Hacks_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_Hack_Done
UR_Drop	Move.w	SD_Drops+SD0_Base(a5),d0
	Cmp.w	SR_Drops(a5),d0
	Ble.s	UR_Drop_Done			Branch if record not broken
	Move.w	d0,SR_Drops(a5)			Store Record
	Lea	SR_Drops_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_Drop_Done
UR_Page	Move.w	SD_Pages+SD0_Base(a5),d0
	Cmp.w	SR_Pages(a5),d0
	Ble.s	UR_Page_Done			Branch if record not broken
	Move.w	d0,SR_Pages(a5)			Store Record
	Lea	SR_Pages_D(a5),a1		Store Date.
	Bsr	ReDCopy
UR_Page_Done
;---------------------------------------------------------------------------;
	Bsr	DayMove			Move days to next one..
	Lea	SD0_Base(a5),a1		Point to our New Day...
	Moveq.l	#(SD_Len/2)-1,d7	Len in words of a Day-Struc, -1word
Day6_L1	Move.w	#0,(a1)+		Clear a word...
	DBra	d7,Day6_L1		Do all the words...
	Move.l	DT_Days(a5),SD_Date+SD0_Base(a5)
	;				Write Today's Date into New Day!

	Lea	D8_Name(a5),a0		Copy ASCII day name...
	Lea	SD_DayName+SD0_Base(a5),a1
	Move.b	(a0)+,(a1)+		-.
	Move.b	(a0)+,(a1)+		 |- Copy 3 chars.
	Move.b	(a0)+,(a1)+		-'
	SF	(a1)+			Ensure it's null-terminated.
	Lea	D8_Date(a5),a0		Copy ASCII date...
	Lea	SD_AsciiDate+SD0_Base(a5),a1
	Moveq	#8,d7			...copy 9 letters...
ADCCLR2	Move.b	(a0)+,(a1)+
	DBra	d7,ADCCLR2
	SF	(a1)+			Ensure it's null-terminated.
;===========================================================================;	
NoClear	Lea	NUS+SU_OnTime(a5),a0	Login Time -> d2
	Move.b	(a0)+,d2		Copy a digit into longword.
	Lsl.l	#8,d2			Move byte over for next one.
	Move.b	(a0)+,d2		Copy a digit into longword.
	Lsl.l	#8,d2			Move byte over for next one.
	Addq.l	#1,a0			Skip ":"
	Move.b	(a0)+,d2		Copy a digit into longword.
	Lsl.l	#8,d2			Move byte over for next one.
	Move.b	(a0)+,d2		Copy a digit into longword.

	Lea	D8_Time(a5),a0		Updating (current) Time -> d1
	Move.b	(a0)+,d1		Copy a digit into longword.
	Lsl.l	#8,d1			Move byte over for next one.
	Move.b	(a0)+,d1		Copy a digit into longword.
	Lsl.l	#8,d1			Move byte over for next one.
	Addq.l	#1,a0			Skip ":"
	Move.b	(a0)+,d1		Copy a digit into longword.
	Lsl.l	#8,d1			Move byte over for next one.
	Move.b	(a0)+,d1		Copy a digit into longword.

	Lea	SD1_Base(a5),a2		Point to previous day's data.
	Cmp.l	d2,d1			Updating "before" logoff?
	Blt.s	IsYDay			YES = Point to previous day's data.
	Lea	SD0_Base(a5),a2		Else point to today's data.
IsYDay
	Addq.w	#1,SD_Calls(a2)			Add 1 to # Calls Today
	BTst	#SU_F1_New,NUS+SU_Flag_1(a5)	Was this a new user?
	Beq.s	Upd_N01				-._ If so,
	Addq.w	#1,SD_NewUsers(a2)		-'  add 1 to count.
Upd_N01
	BTst	#SU_F1_Hack,NUS+SU_Flag_1(a5)	Did this user hack?
	Beq.s	Upd_N02				-._ If so,
	Addq.w	#1,SD_Hacks(a2)			-'  add 1 to count.
Upd_N02
	BTst	#SU_F1_Drop,NUS+SU_Flag_1(a5)	Did this user drop?
	Beq.s	Upd_N03				-._ If so,
	Addq.w	#1,SD_Drops(a2)			-'  add 1 to count.
Upd_N03
	Move.w	UpFiles(a5),d0			-.
	Add.w	d0,SD_UpFiles(a2)		 |
	Move.l	UpBytes(a5),d0			 |
	Add.l	d0,SD_UpKBytes(a2)		 |_ Add Bytes/Files
	Move.w	DnFiles(a5),d0			 |  To Total Count.
	Add.w	d0,SD_DnFiles(a2)		 |
	Move.l	DnBytes(a5),d0			 |
	Add.l	d0,SD_DnKBytes(a2)		-'
	Move.w	Pages(a5),d0			-._ Add #Pages to
	Add.w	d0,SD_Pages(a2)			-'  Daily Total

;;;;;;;	d2 still contains login time. "HHMM"
	Move.l	OnMins(a5),d0		Mins after midnight of login.
	Divs.w	#60,d0			Find number of hours after midnight.
	Move.l	d0,d2			-._ Preserve remaining mins
	Swap	d2			-'  into d2.
	Muls.w	#SD_H_Len,d0		Multiply by length of Hour structs.
	And.l	#$FFFF,d2		Clear high word of d2.
	Lea	SD_H00_Calls(a2,d0.w),a3	Point to start of Hour struct.
	Lea	SD_H23_Calls+SD_H_Len(a2),a4	Point to end+1 of last struct.
	Lea	SD0_Base+SD_H00_Calls(a5),a0	Point to first day's hours.
	Addq.w	#1,(a3)+		Add to Nº callers this hour.
;;;;;;;	Pointer now to word of used mins for that hour.

	Move.l	Usage(a5),d5		Mins that the user was online for.
	Moveq	#60,d4			-.  Mins left in current hour
	Move.l	d4,d3			 |- now in d3.
	Sub.l	d2,d3			-'  And d4 has #60.

NxtHour	Cmp.l	d3,d5			More mins left in hour than used?
	Ble.s	UsgLast			YUP = Just add remaining to this hour.

	Addq.w	#1,(a3)			Update Users in this hour.
	Add.w	d3,2(a3)		Update Mins used for this hour.
	Add.l	d3,SD_UsedMins(a2)	Update Mins used for this day.
	Sub.l	d3,d5			Update remaining Usage to add.
	Move.l	d4,d3			Now 60 Mins left in each hour.

	Addq.l	#SD_H_Len,a3		Point to next hour structure.
	Cmp.l	a4,a3			Pointing past the 23 hour of this day?
	Blt.s	NxtHour			No, continue adding to this day.
	Lea	SD_Len(a2),a2		Point to previous day structure.
;;;;;;;	Shouldn't normally happen, but just incase the callerslog = invalid:
	Cmp.l	a0,a3			Pointing before 1st stucture??
	Blt	InvCLog			YES = Invalid Callerslog.
	Lea	SD_H00_Calls(a2),a3	Point to 1st hour structure.
	Bra.s	NxtHour

UsgLast	Addq.w	#1,(a3)+		Update Users in this hour.
	Add.w	d5,(a3)			Update Mins used for this hour.
	Add.l	d5,SD_UsedMins(a2)	Update Mins used for this day.

	Bsr	UsrMove			Shift Users by one, copy NUS to User1
;---------------------------------------------------------------------------;
; Write out new Storage File                                                ;
;---------------------------------------------------------------------------;
; This seek isn't really needed, but it's here, just in case...
; come to think of it, maybe I do need it.. well leave it either way!!
	Lea	Store(pc),a0
	Move.l	a0,FileNam(a5)
	Move.l	StorHdl(a5),d1		FileHandle
	Moveq	#0,d2			-._ 0 Byte Offset
	Moveq	#OFFSET_BEGINNING,d3	-'  from the Start of the file.
	CALLDOS	Seek			Seek to the Start of the file.
;	Cmpi.l	#-1,d0			-._ Removed
;	Beq	Error			-'  See Seek(),BUGS in Autodocs
	CALLDOS	IoErr			Will return 0 on Success.
	Tst.l	d0			-._ If an error was returned,
	Bne	Error			-'  branch to the error routine.
	Lea	StorFil(a5),a0		-.
	Move.l	a0,d2			 |
	Move.l	#S_Size,d3		 |_ Write New Storage File
	Move.l	StorHdl(a5),d1		 |
	CALLDOS	Write			-'
	Cmpi.l	#-1,d0
	Beq	Error
	Move.l	#0,FileNam(a5)		Clear filename.
;*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*;
* Create/Update the MiniCallerslog, If required                             *
;*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*;
;	Moved to moreoldsh.s
;=============================================================================;
	RTS				Routine Done.
;=============================================================================;
*****************************************************************************
*****************************************************************************
*- UPLOAD/DOWNLOAD INFO GRABBER -********************************************
* Temp1(a5) - Address " file(s), " etc * Temp2(a5) - Address #UP/DOWNloads  *
* Temp3(a5) - Address #UP/DOWN KBytes  * Temp4(a5) - Address #NOW-UP/DOWN   *
* Temp5(a5) - Adr to write NOW-#Files  * Temp6(a5) = <Temp>                 *
* Temp7(a5) = <Temp>                   *                                    *
*****************************************************************************
* The upload/download bit the NCP_F_1 should also be set correctly.         *
*****************************************************************************
UPDNInf	Move.l	StarRef(a5),a0		Start of search area (After location)
	Move.l	EndRef(a5),d6		Moveing Forwards, checking for END.
UPFLoop	Move.l	Temp001(a5),a2		Searching for " file(s), " (Ups)
;;;;;;;					Searching for " files, "   (Dns)
	Bsr	SAdrStr			Get offset from a0 to files, into d3
	Cmpi.l	#-1,d3			-._ If none found, then work out the
	Beq	UpConv			-'  totals (?)
	Add.l	d3,a0			Point to start of " file(s) " (Ups)
	Subq.l	#1,a0			Now pointing to UNITS of #Files
;	No need to check if within file as search FOUND the string.

;;;;;;;	In case this is not a real upload, but is just the moving of files
;;;;;;;	from LCFiles/ , check to make sure that an upload has taken place
;;;;;;;	(Uploading FILENAME  761069 bytes, or something similar will be
;;;;;;;	before this line in the log. " bytes",10 will ALWAYS be part of the
;;;;;;;	line (as opposed to "Uploading" which could be "Resuming", or
;;;;;;;	"downloading"). Note "Resuming" line ends with " bytes ["<Nº>"]",10

	Lea	ByteBck(pc),a2		Search backwards for " bytes"<CR>
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBaStAd			Is it there?
	Move.l	d3,-(SP)		Preserve result.

	Lea	ByteBk2(pc),a2		Search backwards for " bytes ["
	Bsr	SBaStAd			Is it there?
	Move.l	(SP)+,d2

;;;;;;;	If the are both equal they must both be #-1 = not found, meaning
;;;;;;;	we should skip this line.
	Cmp.l	d2,d3
	Beq.s	Yes_LCF
;;;;;;;	If d2 is negative, must not be used, and d3 must be +ve/0
	Cmpi.l	#-1,d2
	Beq.s	Not_LCF			Use d3.
;;;;;;;	If d3 is negative, use d2.
	Cmpi.l	#-1,d3
	Beq.s	No2_LCF			Use d2.
;;;;;;;	Else they must have both been found. Want to use the nearest.
	Cmp.l	d2,d3
	Blt.s	Not_LCF			d3<d2 = Use d3
	Bra.s	No2_LCF			d3>d2 = Use d2
ByteBck	Dc.b	10,"setyb ",0		" bytes"<CR> for backward search.
ByteBk2	Dc.b	"[ setyb ",0		" bytes [" for backward search.
	Even

Yes_LCF	Move.b	#10,d0			Gunna look for <RETURN>, EOL.
	Move.l	EndRef(a5),d6		Stop search at end of file.
	Bsr	SAdrByt			Find it.
	Cmpi.l	#-1,d3			-._ No return = 
	Beq	InvCLog			-'  Callerslog invalid.
	Add.l	d3,a0			Point to the EOL
;	No need to check if within file as search FOUND the character.
	Bra.s	UPFLoop

No2_LCF	Move.l	d2,d3
Not_LCF	Move.l	a0,Temp007(a5)		-._ Store pointer for TopCPS's
	Sub.l	d3,Temp007(a5)		-'  filename routine.

; Distance from a0 to next space is number of digits to convert.
	Move.b	#" ",d0			Gunna look for a space.
;;;;;;;	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space = 
	Beq	InvCLog			-'  Callerslog invalid.

	Move.l	EndRef(a5),d6

	Move.l	d3,d2			Number of digits now in d2.
	Sub	d3,a0			Point to the found space.
	Addq.l	#1,a0			Point to First Dig (NOt the Space!)
	Cmp.l	d6,a0			-._ If past the end,
	Bge	InvCLog			-'  CallersLog is invalid.

	Bsr	Asc2Num			Convert Ascii at a0 into Number in d0
	Move.l	Temp002(a5),a3		Get address of number of Files.
	Add.w	d0,(a3)			Add to them!

	BClr	#SC_F1_Batch,NCP_F_1(a5)
	Cmpi.w	#1,d0			Was only 1 file uploaded?
	Ble.s	UDI1Fil			Yup = Not Batch.
	BSet	#SC_F1_Batch,NCP_F_1(a5) Else IS a Batch transfer.
UDI1Fil

;;;;;;;	Move.l	EndRef(a5),d6
	Move.b	#"k",d0			Searching for "k" at end of upl size.
	Bsr	SAdrByt
	Cmpi.l	#-1,d3			-._ Not found =
	Beq	InvCLog			-'  Callerslog invalid.

	Add.l	d3,a0			point to "k"
	Subq.l	#1,a0			Point to UNITS of kbytes

	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space = 
	Beq	InvCLog			-'  Callerslog invalid.

	Move.l	EndRef(a5),d6

	Subq.l	#1,d3			Ignore the space.
	Move.l	d3,d2			Number of digits now in d2.
	Sub.l	d3,a0			Point to the found space.

	Bsr	Asc2Num			Convert Ascii at a0 into Number in d0
	Move.l	Temp003(a5),a3		Get address of number of uploaded bytes
	Add.l	d0,(a3)			Add to them!
	Move.l	d0,Temp006(a5)		Store batch-size for TopCPS routines..


TopCPSR	Lea	CpsStr(pc),a2		Searching for " cps, "
	Bsr	SAdrStr			Get offset from a0 to string, into d3
	Cmpi.l	#-1,d3			-._ If not found,
	Beq	InvCLog			-'  Callerslog is invalid
	Add.l	d3,a0			Point to start of " cps, "
	Subq.l	#1,a0			Now pointing to UNITS of CPS
;	No need to check if within file as search FOUND the string.

	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space = 
	Beq	InvCLog			-'  Callerslog invalid.

	Move.l	EndRef(a5),d6


	Cmpi.l	#4,d3			More than 4 digits CPS? (FAST!!)
	Bgt	UPFLoop			YES=Too big, skip CSP part. NEXT FILE
	Move.l	d3,d2			Number of digits now in d2 for A2#
	Move.l	a0,a2			-._ Setup a2 for
	Addq.l	#1,a2			-'  ASCII CPS copy below.
	Sub.l	d3,a0			Point to 1st (MS) digit.
	Addq.l	#1,a0			Point past the space.

	Lea	TempCPS+4(a5),a3	Point to END+1 CPS Store
	Move.l	#"   0",-4(a3)		ASCII-Clear CPS store. " " = "0"
	Bra.s	TCPSCJm
TCPSCLp	Move.b	-(a2),-(a3)		copy the CPS rate...
TCPSCJm	DBra	d3,TCPSCLp

	Bsr	Asc2Num			Convert Ascii at a0 into Number in d0
	Add.l	d0,TotlCPS(a5)		Add to sum of user's CPS rates.
	Addq.l	#1,NumbCPS(a5)		and increment number of rates.

	Move.l	TempCPS(a5),d0
	Cmp.l	SCR20_Base(a5),d0	Is this greater than MIN CPS?
	Blt	UPFLoop			NO = Don't add it then. NEXT FILE.

CPSBIT	Move.l	a0,-(SP)		Preserve a0

;;;;;;;	Else overwrite the new obsolete worst CPS with the new one.
;;;;;;; The list will then be sorted.

	Move.l	d0,SCR20_Base(a5)		New CPS Rate.
	Move.w	SC_Ptr+SCR20_Base(a5),d0	Number of wanted item.
	And.l	#$FFFF,d0			Clear any junk in high word
	Muls.w	#SC_Len,d0			Now we have the distance.
;;;;;;;	Lea	SC01_Base(a5,d0),a1		Point to wanted item.
;;;;;;; Cannot just do above because SC01_Base too large a displacement.
	Lea	SC01_Base(a5),a4		Point to base of data array
	Add.l	d0,a4				Point to wanted item.

	Move.l	EndRef(a5),d6
	Lea	EffStr(pc),a2		Searching for " % efficiency "
	Bsr	SAdrStr			Get offset from a0 to string, into d3
	Cmpi.l	#-1,d3			-._ If not found,
	Beq	InvCLog			-'  Callerslog is invalid
	Add.l	d3,a0			Point to start of " % eff..."
	Subq.l	#1,a0			Now pointing to UNITS
	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space =
	Beq	InvCLog			-'  Callerslog invalid.
	Lea	SC_Effy(a4),a1		Destin: Effy space in CPS Record Data
	Move.l	#"   0",(a1)+		ASCII-Clear Secs store. " " = "0"
	Cmpi.l	#4,d3			More than 4 digits?
	Bgt.s	DonEffy			YES=Too high (over 9999%!!), skip.
	Addq.l	#1,a0
	Bra.s	TCPSCEJ
TCPSCEL	Move.b	-(a0),-(a1)		copy the %-Eff attained...
TCPSCEJ	DBra	d3,TCPSCEL
DonEffy
	Move.l	Temp007(a5),a0		Point to " bytes",10 after filename/size
;;;;;;;					This here coz " cps, " AFTER Mins/Secs
	Move.l	EndRef(a5),d6
	Lea	MinStr(pc),a2		Searching for " minutes "
	Bsr	SAdrStr			Get offset from a0 to string, into d3
	Cmpi.l	#-1,d3			-._ If not found,
	Beq	InvCLog			-'  Callerslog is invalid
	Add.l	d3,a0			Point to start of " minutes "
	Subq.l	#1,a0			Now pointing to UNITS of minutes
	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space =
	Beq	InvCLog			-'  Callerslog invalid.
	Lea	SC_Mins(a4),a1		Destin: Mins space in CPS Record Data
	Move.l	#"AGES",(a1)
	Cmpi.l	#4,d3			More than 4 digits Minutes? (166HOURS!)
	Bgt.s	DonMins			YES=Too big, skip.
	Addq.l	#1,a0
	Move.l	#"   0",(a1)+		ASCII-Clear Mins store. " " = "0"
	Bra.s	TCPSCMJ
TCPSCML	Move.b	-(a0),-(a1)		copy the Minutes taken...
TCPSCMJ	DBra	d3,TCPSCML
DonMins	

	Move.l	EndRef(a5),d6
	Lea	SecStr(pc),a2		Searching for " seconds "
	Bsr	SAdrStr			Get offset from a0 to string, into d3
	Cmpi.l	#-1,d3			-._ If not found,
	Beq	InvCLog			-'  Callerslog is invalid
	Add.l	d3,a0			Point to start of " seconds "
	Subq.l	#1,a0			Now pointing to UNITS of seconds
	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space =
	Beq	InvCLog			-'  Callerslog invalid.
	Lea	SC_Secs(a4),a1		Destin: Secs space in CPS Record Data
	Move.w	#" 0",(a1)+		ASCII-Clear Secs store. " " = "0"
	Cmpi.l	#2,d3			More than 2 digits?
	Bgt.s	DonSecs			YES=Invalid, skip.
	Addq.l	#1,a0
	Bra.s	TCPSCSJ
TCPSCSL	Move.b	-(a0),-(a1)		copy the Seconds taken...
TCPSCSJ	DBra	d3,TCPSCSL
DonSecs	

	Lea	NUS+SU_Name(a5),a0	Source: Original Name
	IFNE	SC_Name
	Lea	SC_Name(a4),a1		Destin: Name space in CPS Record Data
	ELSE
	Lea	(a4),a1
	ENDC
CpyNTJ0	Move.b	(a0)+,(a1)+		Copy the next char
	Bne.s	CpyNTJ0			Copy till null copied.

	Lea	NUS+SU_Location(a5),a0	Source: Original Location
	Lea	SC_Location(a4),a1	Destin: Loca space in CPS Record Data
CpyNTJ1	Move.b	(a0)+,(a1)+		Copy the next char
	Bne.s	CpyNTJ1			Copy till null copied.

	Lea	NUS+SU_Baud(a5),a0	Source: Original Baud
	Lea	SC_Baud(a4),a1		Destin: Baud space in CPS Record Data
CpyNTJ2	Move.b	(a0)+,(a1)+		Copy the next char
	Bne.s	CpyNTJ2			Copy till null copied.


	Bsr	FilInD8			Fill In Date Strings...

	Lea	SC_Date(a4),a1		Destin: Date space in CPS Record Data
	Lea	D8_Name(a5),a0
	Move.b	(a0)+,(a1)+
	Move.b	(a0)+,(a1)+
	Move.b	(a0)+,(a1)+
	Move.b	#",",(a1)+
	Move.b	#" ",(a1)+
	Lea	D8_Date(a5),a0
	Moveq	#8,d7			...copy 9 letters...
ADCCLR3	Move.b	(a0)+,(a1)+
	DBra	d7,ADCCLR3
	SF	(a1)+			Ensure it's null-terminated.

	Move.b	NCP_F_1(a5),SC_Flag_1(a4)	Copy our setup flag byte

	Move.l	Temp006(a5),d1		Size of (batch) upload
	Lea	SC_Size(a4),a1		Destin: Space for Size...
	Cmpi.l	#9999,d1		Over 9999k Up/Dnloaded?
	Bgt.s	Big1CPS			Yup!...
	Bsr	N2A4Dig			Number»Ascii d1 into (a1)
	Moveq	#3,d1			4 Digit Number (only do first 3)
	Lea	SC_Size(a4),a1		Destin: Space for Size...
	Move.b	#"k",4(a1)		Size = "k"bytes
	Bsr	NoZero			Replace left 0's with spaces
	Bra.s	DSzeCPS
Big1CPS	Divs.w	#1024,d1		Get amount in MegaBytes
	And.l	#$FFFF,d1		Nuke Remainder.
	Cmpi.l	#99,d1			Over 99meg?
	Bgt.s	Big2CPS			Write "v.BIG"
	Bsr	N2A2Dig			Convert 2 Digit Number
	Moveq	#1,d1			2 Digit Number (affect only first)
	Lea	SC_Size(a4),a1		Destin: Space for Size...
;;;;;;;	Move.w	#"mb",2(a1)		Write "mb" after the number.
;;;;;;;	Move.b	#" ",4(a1)
	Move.l	#$6D622000,2(a1)
	Bsr	NoZero			Replace left 0's with spaces
	Bra.s	DSzeCPS
Big2CPS	Move.l	#"v.BI",(a1)+
	Move.b	#"G",(a1)
DSzeCPS


	Move.l	Temp007(a5),a0		Point to " bytes",10 after filename/size

	Move.b	#" ",d0			Gunna look for a space.
	Move.l	StarRef(a5),d6		Stop search at top of file.
	Bsr	SBAdByt			Find it.
	Cmpi.l	#-1,d3			-._ No space = 
	Beq	InvCLog			-'  Callerslog invalid.
	Sub.l	d3,a0			Point to the space.
	Move.l	a0,d3

;;;;;;;	Move.l	StarRef(a5),d6		Stop search at top of file.
ErpSpaL	Cmpi.b	#" ",-1(a0)		Find first NON-Space char...
	Bne.s	ErpSpac
	Subq.l	#1,a0
	Cmp.l	d6,a0			-._ If past the start,
	Bgt.s	ErpSpaL
	Bra	InvCLog			-'  CallersLog is invalid.
ErpSpac

	Move.b	#" ",d0			If uploading, no path.
	Move.b	#"/",d1			Downloading, eg "BBS:Files/ERPY.DMS"
	Move.b	#":",d2			Downloading, eg "FILES:ERPY.DMS"
Fnd3	Cmp.l	d6,a1			-._ Ensure we don't go past
	Ble	InvCLog			-'  the start of the file.
	Cmp.b	-(a0),d0		-.
	Beq.s	Fnd3Fnd			 |
	Cmp.b	(a0),d1			 |_ Search 'till one of them
	Beq.s	Fnd3Fnd			 |  has been found.
	Cmp.b	(a0),d2			 |
	Bne.s	Fnd3			-'
Fnd3Fnd	Addq.l	#1,a0			Source: Actual filename itself.
	Sub.l	a0,d3			Which is this long.
	Lea	SC_FileName(a4),a1	Destin: Space for Filename.
	Moveq	#SC_FileName_Len,d1	Which is this long.
	Bsr	SpaOver			Overlay them w/ space padding.

;--> SORT THE CPS Scores

	BClr	#X1_SortChange,Fil_F_1(a5)	Make sure Change bit is clear.
SortCPS	Moveq	#18,d7			20 records (-1 dbra, -1 coz 19 sorts)
;;;;;;;					Only 19 compares per sort, NOT 20
	Lea	SCR01_Base(a5),a0	Point to 1st CPS record
SrtLoop	Move.l	(a0),d0
	Cmp.l	8(a0),d0
	Bge.s	SrtNChg			Skip if 1st >= 2nd

	BSet	#X1_SortChange,Fil_F_1(a5)	List will need sorting again
	Move.l	8(a0),(a0)		-._ Swap the
	Move.l	d0,8(a0)		-'  CPS rates
	Move.l	4(a0),d0		-.
	Move.l	12(a0),4(a0)		 |- Swap the data pointers.
	Move.l	d0,12(a0)		-'

SrtNChg	Addq.l	#8,a0			Point to next record
	DBra	d7,SrtLoop		Sort 'em all.
	BClr	#X1_SortChange,Fil_F_1(a5)	Make sure Change bit is clear.
	Bne.s	SortCPS			If it was set, sort again.

;--> CPS Scores Sorted!

	Move.l	(SP)+,a0		Restore a0
	Bra	UPFLoop			Check for more uploads.

CpsStr	Dc.b	" cps, ",0
MinStr	Dc.b	" minute",0		/X2: " minutes " /X3: " minute(s). "
SecStr	Dc.b	" second",0		/X2: " seconds " /X3: " second(s), "
EffStr	Dc.b	" % efficiency",0
UpFile	Dc.b	" file(s), ",0
DnFile	Dc.b	" files, ",0
	Even
;---------------------------------------------------------------------------;
UpConv	Move.l	Temp002(a5),a1		-.
	Move.w	(a1),d1			 |- Get this user's #Files
	And.l	#$FFFF,d1		-'
	Move.l	Temp005(a5),a1		Point to Space for ASCII output.
	Bsr	N2A4Dig			Write ASCII Number (4 digits)
	Moveq	#3,d1			-.
	Move.l	Temp005(a5),a1		 |- Remove Zeros
	Bsr	NoZero			-'

	Move.l	Temp003(a5),a1		-._ Get this user's
	Move.l	(a1),d1			-'  Number of bytes
	Move.l	Temp004(a5),a1		Point to Space for ASCII output.
	Cmpi.l	#9999,d1		Over 9999k Up/Dnloaded?
	Bgt.s	BigOne			Yup!...
	Bsr	N2A4Dig			Number»Ascii d1 into (a1)
	Moveq	#3,d1			4 Digit Number (only do first 3)
	Move.l	Temp004(a5),a1		Point to Space for his uploads
	Bra	NoZero			Replace left 0's with spaces
;	RTS done for us by above routine.
BigOne	Divs.w	#1024,d1		Get amount in MegaBytes
	And.l	#$FFFF,d1		Nuke Remainder.
	Cmpi.l	#99,d1			Over 99meg?
	Bgt.s	BigOne2			Write "LOTS"
	Bsr	N2A2Dig			Convert 2 Digit Number
	Moveq	#1,d1			2 Digit Number (affect only first)
	Move.l	Temp004(a5),a1		Point to Space for his uploads
	Move.w	#"mb",2(a1)		Write "mb" after the number.
	Bra	NoZero			Replace left 0's with spaces
;	RTS done for us.
BigOne2	Move.l	#"LOTS",(a1)
	RTS
*****************************************************************************
*****************************************************************************
*- DAY MOVE -****************************************************************
* Shifts all Days in Callerslog by one day. (Day 7 disgarded)               *
*****************************************************************************
DayMove	Lea	SD6_Base(a5),a0		-.
	Lea	SD7_Base(a5),a1		 |- Copy Day6 -> 7
	Bsr.s	DayM_R1			-'
	Lea	SD5_Base(a5),a0		-.
	Lea	SD6_Base(a5),a1		 |- Copy Day5 -> 6
	Bsr.s	DayM_R1			-'
	Lea	SD4_Base(a5),a0		-.
	Lea	SD5_Base(a5),a1		 |- Copy Day4 -> 5
	Bsr.s	DayM_R1			-'
	Lea	SD3_Base(a5),a0		-.
	Lea	SD4_Base(a5),a1		 |- Copy Day3 -> 4
	Bsr.s	DayM_R1			-'
	Lea	SD2_Base(a5),a0		-.
	Lea	SD3_Base(a5),a1		 |- Copy Day2 -> 3
	Bsr.s	DayM_R1			-'
	Lea	SD1_Base(a5),a0		-.
	Lea	SD2_Base(a5),a1		 |- Copy Day1 -> 2
	Bsr.s	DayM_R1			-'
	Lea	SD0_Base(a5),a0		-.
	Lea	SD1_Base(a5),a1		 |- Copy Day0 -> 1
;;;;;;;	Bsr.s	DayM_R1			-'
DayM_R1	Moveq	#(SD_Len/2)-1,d7	Len in words of a Day-Struc, -1 word
DayM_L1	Move.w	(a0)+,(a1)+		Move a word from DayX -> X+1
	DBra	d7,DayM_L1		Do all the words...
	RTS
*****************************************************************************
*****************************************************************************
*- USER MOVE -***************************************************************
* Shifts all Users in Storage file. User20 is disgarded. NUS becomes User1  *
*****************************************************************************
UsrMove	Lea	SU19_Base(a5),a0	-.
	Lea	SU20_Base(a5),a1	 |- Copy User19 -> 20
	Bsr	UsrM_R1			-'
	Lea	SU18_Base(a5),a0	-.
	Lea	SU19_Base(a5),a1	 |- Copy User18 -> 19
	Bsr	UsrM_R1			-'
	Lea	SU17_Base(a5),a0	-.
	Lea	SU18_Base(a5),a1	 |- Copy User17 -> 18
	Bsr	UsrM_R1			-'
	Lea	SU16_Base(a5),a0	-.
	Lea	SU17_Base(a5),a1	 |- Copy User16 -> 17
	Bsr	UsrM_R1			-'
	Lea	SU15_Base(a5),a0	-.
	Lea	SU16_Base(a5),a1	 |- Copy User15 -> 16
	Bsr	UsrM_R1			-'
	Lea	SU14_Base(a5),a0	-.
	Lea	SU15_Base(a5),a1	 |- Copy User14 -> 15
	Bsr	UsrM_R1			-'
	Lea	SU13_Base(a5),a0	-.
	Lea	SU14_Base(a5),a1	 |- Copy User13 -> 14
	Bsr	UsrM_R1			-'
	Lea	SU12_Base(a5),a0	-.
	Lea	SU13_Base(a5),a1	 |- Copy User12 -> 13
	Bsr.s	UsrM_R1			-'
	Lea	SU11_Base(a5),a0	-.
	Lea	SU12_Base(a5),a1	 |- Copy User11 -> 12
	Bsr.s	UsrM_R1			-'
	Lea	SU10_Base(a5),a0	-.
	Lea	SU11_Base(a5),a1	 |- Copy User10 -> 11
	Bsr.s	UsrM_R1			-'
	Lea	SU09_Base(a5),a0	-.
	Lea	SU10_Base(a5),a1	 |- Copy User09 -> 10
	Bsr.s	UsrM_R1			-'
	Lea	SU08_Base(a5),a0	-.
	Lea	SU09_Base(a5),a1	 |- Copy User08 -> 09
	Bsr.s	UsrM_R1			-'
	Lea	SU07_Base(a5),a0	-.
	Lea	SU08_Base(a5),a1	 |- Copy User07 -> 08
	Bsr.s	UsrM_R1			-'
	Lea	SU06_Base(a5),a0	-.
	Lea	SU07_Base(a5),a1	 |- Copy User06 -> 07
	Bsr.s	UsrM_R1			-'
	Lea	SU05_Base(a5),a0	-.
	Lea	SU06_Base(a5),a1	 |- Copy User05 -> 06
	Bsr.s	UsrM_R1			-'
	Lea	SU04_Base(a5),a0	-.
	Lea	SU05_Base(a5),a1	 |- Copy User04 -> 05
	Bsr.s	UsrM_R1			-'
	Lea	SU03_Base(a5),a0	-.
	Lea	SU04_Base(a5),a1	 |- Copy User03 -> 04
	Bsr.s	UsrM_R1			-'
	Lea	SU02_Base(a5),a0	-.
	Lea	SU03_Base(a5),a1	 |- Copy User02 -> 03
	Bsr.s	UsrM_R1			-'
	Lea	SU01_Base(a5),a0	-.
	Lea	SU02_Base(a5),a1	 |- Copy User01 -> 02
	Bsr.s	UsrM_R1			-'
	Lea	NUS(a5),a0		-.
	Lea	SU01_Base(a5),a1	 |- Copy New User -> 01
;;;;;;;	Bsr.s	UsrM_R1			-'
UsrM_R1	Moveq	#(SU_Len/2)-1,d7	Len in words of a Day-Struc, -1 word
UsrM_L1	Move.w	(a0)+,(a1)+		Move a word from DayX -> X+1
	DBra	d7,UsrM_L1		Do all the words...
	RTS
