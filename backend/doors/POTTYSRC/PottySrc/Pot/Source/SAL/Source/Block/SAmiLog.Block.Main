*****************************************************************************
* Block-Allocated Output Routines FOR SUPERAMILOG3.                         *
*****************************************************************************


*= ALLOCATE OUTPUT BLOCK =***************************************************
* BlkCurr(a5) = (Adr of new Block)    * BlkEnd(a5) = (Adr of END new Block) *
* (a1) = (Adr to start writting into) * BlkCurr(a5) = (LW Pointer = NULL)   *
*  d6  = ( BlkEnd(a5) )               *                                     *
*=> If the first block: <=============*=====================================*
* #X1_OutBlks Set.                    *                                     *
*=> If *NOT* the first block: <=======*=====================================*
* Old BlkCurr(a5) = Adr of new Block. *                                     *
*****************************************************************************
* After calling the first time:                                             *
;	Move.l	BlkCurr(a5),BlkBase(a5)	Store Base-Block Address
*****************************************************************************
AlocOutBlock
	Movem.l	d0-5/d7/a0/a2-4,-(SP)	Preserve except d6/a1/a5-6
	Move.l	#BlockAloSize,d0	Size of mem to Alloc.
	Moveq	#Memf_Public,d1		Public.
	CALEXEC	AllocMem
	Move.l	BlkCurr(a5),a1		Keep adr of old block...
	Move.l	d0,BlkCurr(a5)		Current Block Adr.
	Beq	Error
	BSet	#X1_OutBlks,Fil_F_1(a5)	Output Block(s) allocated.
	Beq.s	NotBlok			Branch if None previously alloced
	Move.l	d0,(a1)			Adr of the new block in the old one.
NotBlok	Move.l	d0,a1			Currently, this is the last block,
	Move.l	#0,(a1)+		So a Null Pointer.
	Move.l	a1,d6			-._ Store adr of END of block
	Add.l	#BlockOutSize,d6	-'  for checking against.
	Move.l	d6,BlkEnd(a5)		NEEDS to be in d6 *AND* BlkEnd(a5)
	Movem.l	(SP)+,d0-5/d7/a0/a2-4	Restore regs
	RTS

*= DE-ALLOCATE OUTPUT BLOCK =************************************************
* De-allocates all the "chain" of blocks pointed to by BlkBase(a5)          *
*****************************************************************************
DeAlocOutBlocks
	BClr	#X1_OutBlks,Fil_F_1(a5)	Output Block(s) de-allocated.
	Beq.s	NoDBlok			If none alloc'd to start with, skip.
DABlkLp	Tst.l	BlkBase(a5)
	Beq.s	NoDBlok			YES=All Blocks Deallocated.
	Move.l	BlkBase(a5),a1		Point to the Base Block.
	Move.l	(a1),BlkBase(a5)	New Base Block Pointer.
;;;;;;;	Move.l	a1,a1			Adr to free already in a1
	Move.l	#BlockAloSize,d0	Size of block to dealoc.
	CALEXEC	FreeMem
	Bra.s	DABlkLp			Dealoc ALL blocks.
NoDBlok	RTS

*= WRITE OUTPUT BLOCKS TO FILE =*********************************************
* Should be called straight after FormTxt                                   *
* Call to WrtBlk2 if file already opened.                                   *
* ** If doing above, must push FTNumChars(a5),-(SP), Open File, WrtBlk2.    *
*****************************************************************************
WrtBlks
	IFD	USUM
	BClr	#F1_Creds1,Fmt_F_1(a5)	-.
	Beq	NoCreds			 |
	BClr	#F1_Creds2,Fmt_F_1(a5)	 |
	Beq	NoCreds			 |_ If they didn't include the
	BClr	#F1_Creds3,Fmt_F_1(a5)	 |  compulsory texts, error msg.
	Beq	NoCreds			 |
	BClr	#F1_Creds4,Fmt_F_1(a5)	 |
	Beq	NoCreds			-'
	ENDC

	BTst	#F1_NoANSI,Fmt_F_1(a5)	Non-ANSI mode?
	Beq.s	WrBANSI
	Bsr	NonANSI_Output_Prep	Open output, headers & tailers.
	Bra.s	WrBNAsk
WrBANSI	Bsr	ANSI_Output_Prep	Open output, headers & tailers.
WrBNAsk	Move.l	d1,-(SP)
	Bsr	FileDe2			Delete old file if there.
	Move.l	(SP)+,FileNam(a5)	Adr of filename for error routine.
	Move.l	#Mode_New,Temp002(a5)	Create new file.
	Bsr	NWrite2			Open it for writting...

	Move.l	HeadSze(a5),d3		-.
	move.l	HeadAdr(a5),a0		 |- Write header file to output.
	Bsr	FilRite			-'

WrtBlk2	Move.l	FTNumChars(a5),d0	Restore Nº Chars written.
	Move.l	BlkBase(a5),a0		Adr of the base block.
OutABlk	Tst.l	(a0)			Is this the last block?
	Beq.s	OutLBlk			YES = Just write d0 chars from it.
;					ELSE  Write BlockSize, take if from d0
	Move.l	#BlockOutSize,d3	Size of block to write.
	Sub.l	d3,d0			About to write this many, update d0.
	Bmi	Internal		If a negative result, internal error.
	Movem.l	d0/a0,-(SP)		Preserve Block Adr & #Chars to output.
	Addq.l	#4,a0			Point to actual data, past ADR Pointer.
	Bsr	FilRite			Write to output file.
	Movem.l	(SP)+,d0/a0		Restore Block Adr & #Chars to output.
	Move.l	(a0),a0			Point to the next block.
	Bra.s	OutABlk			Write out this block.

OutLBlk	Move.l	d0,d3			Number of chars to write.
	Addq.l	#4,a0			Point to actual data, past ADR Pointer.
	Bsr	FilRite			Write to output file.
	Move.l	TailSze(a5),d3		-.
	move.l	TailAdr(a5),a0		 |- Write tailer file to output.
	Bsr	FilRite			-'
	Bra	BigDAlo			Close Output file, deallocate blocks,
;;;;;;;	RTS for us.			and deallocate header/tailer files.
*= FORMAT TEXT =*************************************************************
* (a0) = Start (end+1) Input string   * (a1) = Start (end+1) output space   *
* InptAdr(a5) = ( Original a0 )       * InptEnd(a5) = ( Original d5 )       *
* FNaFTxt(a5) - Filename of Input Txt * OutANSI / OutNoANSI(a5) - Out FName *
*  d0  = (Number of chars written)    *  d1  = <Temp>                       *
*  d5  - Adr end+1 of Input String    *  d6  = ( BlkEnd(a5) )               *
*****************************************************************************
* ( d2 / d3 / d4 / a2 / a3 / a4 ) Are free for use within the sub-sections. *
* After calling FormTxt, assume that all registers have changed.            *
* WrtBlks should be called straight after FormTxt, unless d0 is preserved.  *
*****************************************************************************
FormTxt	Move.w	#16,NamLen(a5)		Default Name length = 16 chars.
	Move.w	#19,LocLen(a5)		Default Loca length = 19 chars.
	Move.w	#8,TimLen(a5)		Default Loca length =  8 chars.
	Move.w	#9,DatLen(a5)		Default Date length =  9 chars.
	Move.w	#RndMax,RndLen(a5)	Default Random Line length = Maximum.
RDatLen_Max = 14
	Move.w	#14,RDatLen(a5)		Default Record-Date length = 14 chars.
	Move.l	a0,InptAdr(a5)		Store adr start of input for BadInput
	Move.l	d5,InptEnd(a5)		Store adr  end  of input for BadInput
	Bsr	AlocOutBlock		Allocate a block for outputting.
	Move.l	BlkCurr(a5),BlkBase(a5)	Store Base-Block Address
; Now a1 is where to write to.

	Move.b	#"@",d1			For speed, the introducer.
	Moveq	#0,d0			Number of chars written = 0
	Move.l	d0,FTNumChars(a5)
	Move.l	BlkEnd(a5),d6		Adr of the end of the current block.
	Bra.s	FTxtSJm
FTxtMan	Cmp.b	(a0),d1			Is it the introducer?
	Beq.s	FTxtInt			YES=Interpret the thing.
	Cmp.l	d6,a1			-.
	Blt.s	FTxNor1			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTxNor1	Move.b	(a0)+,(a1)+		Just copy the char...
	Addq.l	#1,d0			Increment number of chars written.
FTxtSJm	Cmp.l	d5,a0			End of input?
	Blt.s	FTxtMan			Nope=Do more.
	Bsr	Store_FT_Regs
	RTS				Return to calling routine.
*****************************************************************************
FTxtInt	Addq.l	#1,a0			Point to the next char.
	Cmp.l	d5,a0			End of input?
	Bge	BadInput

	Bsr	Store_FT_Regs

	Lea	User_CMD(pc),a2		Command String (Uppercase)
	Lea	User__CMD-1(pc),a3	Command String (Lowercase)
	Bsr.s	FTSerch			Search for it.
	Beq	FTxt_User		If found, do the command.

	Lea	Text_CMD(pc),a2		Command String (Uppercase)
	Lea	Text__CMD-1(pc),a3	Command String (Lowercase)
	Bsr.s	FTSerch			Search for it.
	Beq	FTxt_Text		If found, do the command.

	Lea	Opt_CMD(pc),a2		Command String (Uppercase)
	Lea	Opt__CMD-1(pc),a3	Command String (Lowercase)
	Bsr.s	FTSerch			Search for it.
	Beq	FTxt_Option		If found, do the command.

	Lea	NOpt_CMD(pc),a2		Command String (Uppercase)
	Lea	NOpt__CMD-1(pc),a3	Command String (Lowercase)
	Bsr.s	FTSerch			Search for it.
	Beq	FTxt_Not_Option		If found, do the command.

	Lea	End_CMD(pc),a2		Command String (Uppercase)
	Lea	End__CMD-1(pc),a3	Command String (Lowercase)
	Bsr.s	FTSerch			Search for it.
	Beq	FTxt_End		If found, do the command.

	Bra	BadInput		Else, Bad Input.
*****************************************************************************
	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Main_Routines
;	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_C
;	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_I
;	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_S
	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_Text
	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_User
	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Command_Option
	Include	ASM:Source/SAL/Source/Block/SAmiLog.Block.Routines
;---------------------------------------------------------------------------;
User_CMD	Dc.b	"USER_",0
User__CMD	Dc.b	"user_",0
Day_CMD		Dc.b	"DAY_",0
Day__CMD	Dc.b	"day_",0
Set_CMD		Dc.b	"SET_",0
Set__CMD	Dc.b	"set_",0
Record_CMD	Dc.b	"RECORD_",0
Record__CMD	Dc.b	"record_",0
CPS_CMD		Dc.b	"CPS_",0
CPS__CMD	Dc.b	"cps_",0
If_CMD		Dc.b	"IF_",0
If__CMD		Dc.b	"if_",0
Text_CMD	Dc.b	"TEXT_",0
Text__CMD	Dc.b	"text_",0
Opt_CMD		Dc.b	"OPT_",0
Opt__CMD	Dc.b	"opt_",0
NOpt_CMD	Dc.b	"NOPT_",0
NOpt__CMD	Dc.b	"nopt_",0
End_CMD		Dc.b	"END_",0
End__CMD	Dc.b	"end_",0
	Even
