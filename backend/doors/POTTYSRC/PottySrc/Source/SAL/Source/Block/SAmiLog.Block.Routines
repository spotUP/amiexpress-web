; Used to use...
;	Movem.l	d0-1/d5-7/a1,-(SP)	Preserve all except ?2/3/4,a0/5/6/7
Store_FT_Regs
	Move.l	d0,FTNumChars(a5)	Store Nº chars written.
	Move.l	a0,FTInptAdr(a5)	Store adr start of input
	Move.l	d5,FTInptEnd(a5)	Store adr  end  of input
	Move.l	d6,FTOBlkEnd(a5)	Store adr of end of output block.
	Move.l	a1,FTOPstion(a5)	Store current adr in output block.
	Move.l	d7,FT_D7(a5)		Store d7 scratch register.
	RTS

Restore_FT_Regs
	Move.b	#"@",d1			For speed, the introducer.
	Move.l	FTNumChars(a5),d0	Restore Nº chars written.
	Move.l	FTInptAdr(a5),a0	Restore adr start of input
	Move.l	FTInptEnd(a5),d5	Restore adr  end  of input
	Move.l	FTOBlkEnd(a5),d6	Restore adr of end of output block.
	Move.l	FTOPstion(a5),a1	Restore current adr in output block.
	Move.l	FT_D7(a5),d7		Restore d7 scratch register.
	RTS
*****************************************************************************
* Puts the "]" term string (a0) into the output (a1) with end chking etc.   *
*****************************************************************************
FTxSOut	Bsr.s	Restore_FT_Regs		Restore regs
	Cmpi.b	#"[",(a0)+
	Bne	BadInput
	Moveq	#"]",d2			For fast compare...
	Bra.s	FTxSOuJ
FTxSOuL	Cmp.b	(a0),d2			-._ If terminating char reached,
	Beq.s	FTxSODn			-'  copy has been finished...
	Cmp.l	d6,a1			-.
	Blt.s	FTxSNr0			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTxSNr0	Move.b	(a0)+,(a1)+		Copy the char...
	Addq.l	#1,d0			Increment number of chars written.
FTxSOuJ	Cmp.l	d5,a0			Make sure (a0) is within the file.
	Blt.s	FTxSOuL			Is = Copy next char.
	Bra	BadInput		Fall through = Bad Input
FTxSODn	Addq.l	#1,a0			Point past the terminator.
	Bra	FTxtSJm			Continue with original input.
*****************************************************************************
* Skips past the "]" term string (a0)                                       *
*****************************************************************************
FTxSSkp	Bsr.s	Restore_FT_Regs		Restore regs
	Cmpi.b	#"[",(a0)+
	Bne	BadInput
	Moveq	#"]",d2			For fast compare...
FTxSSLp	Cmp.l	d5,a0			Make sure (a0) is within the file.
	Bge	BadInput		Isn't = Bad Input error.
	Cmp.b	(a0)+,d2		-._ If terminating char reached,
	Bne.s	FTxSSLp			-'  skipping has been finished...
	Bra	FTxtSJm			Continue with original input.
*****************************************************************************
* Puts the nullterm string (a2) into the output (a1) with end chking etc.   *
*****************************************************************************
FTx_Out	Bsr.s	Restore_FT_Regs		Restore regs
FTx_OTM	Tst.b	(a2)			Is it the end of the string?
	Beq	FTxtSJm			YUP! = Continue with original input.
FTx_OTJ	Cmp.l	d6,a1			-.
	Blt.s	FTxNor2			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTxNor2	Move.b	(a2)+,(a1)+		Copy the char...
	Addq.l	#1,d0			Increment number of chars written.
	Bra.s	FTx_OTM
*****************************************************************************
* Puts the nullterm string (a2) into the output (a1) with end chking etc.   *
* Does till null, max chars = d2					    *
*****************************************************************************
FTxLOut	Bsr.s	Restore_FT_Regs		Restore regs
FTxLOTM	Tst.b	(a2)			Is it the end of the string?
	DBeq	d2,FTxLOTJ		DON'T Jump if END of copy.
	Bra	FTxtSJm			Continue with original input.
FTxLOTJ	Cmp.l	d6,a1			-.
	Blt.s	FTxLor2			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTxLor2	Move.b	(a2)+,(a1)+		Copy the char...
	Addq.l	#1,d0			Increment number of chars written.
	Bra.s	FTxLOTM
*= Length Output Record-Date routine =***************************************
* Note: Calls FTxLOut                                                       *
*****************************************************************************
FTxLORD	Move.w	RDatLen(a5),d2		Length to write.
	And.l	#$FFFF,d2		Clear any junk in high word.
	Move.l	d2,d3			Preserve d2
	Sub.w	#RDatLen_Max,d3		This SHOULD be negative or zero...
	Neg.w	d3			Now SHOULD BE positive or zero...
	Bmi.s	FTLORDN			-ve: Given length over maximum...
	Add.l	d3,a2			Point to part to send.
	Bra.s	FTxLOut
FTLORDN	Move.w	#RDatLen_Max,RDatLen(a5)	Set Length to Max.
	Bra.s	FTxLORD			Do above routine again.
*****************************************************************************
* Puts d2.b into the output.                                                *
*****************************************************************************
FTCOt_O	Move.b	FT_If_O(a5),d2		Use char for when IF= 3rd option.
	Bra.s	FTChOut
FTCOt_T	Move.b	FT_If_T(a5),d2		Use char for when IF=TRUE
	Bra.s	FTChOut
FTCOt_F	Move.b	FT_If_F(a5),d2		Use char for when IF=FALSE

FTChOut	Bsr	Restore_FT_Regs		Restore regs
	Cmp.l	d6,a1			-.
	Blt.s	FTCONo4			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTCONo4	Move.b	d2,(a1)+		Write the char...
	Addq.l	#1,d0			Increment number of chars written.
	Bra	FTxtSJm			Continue with original input.
*****************************************************************************
* For outputting number->ascii stuff.                                       *
*****************************************************************************
FTxNum4	And.l	#$FFFF,d2
	Lea	NAB4Dig(pc),a2
FTxNumX	Bsr	Restore_FT_Regs		Restore regs
	Bsr	NABJump
	Bra	FTxtSJm			Continue with original input.
*****************************************************************************
* Input for command "Character Copy"                                        *
* [X_##] - X = Character, ## = Nº times to write it out (0-99)              *
*****************************************************************************
FTxt_CC	Addq.l	#1,a0
	Subq.l	#4,d5			(Going to read 4 chars ahead)
	Cmp.l	d5,a0			End of input?
	Bge.s	BadInput
	Addq.l	#4,d5

	Move.b	(a0)+,d3		Char to copy -> d3 (Not used by A2#)

	Cmpi.b	#"_",(a0)+
	Bne.s	BadInput

	Cmpi.b	#"0",(a0)		-.
	Blt.s	BadInput		 |_ Make Sure 1st digit is a number
	Cmpi.b	#"9",(a0)		 |  If not, Invalid CommandLine
	Bgt.s	BadInput		-'

	Moveq	#2,d2			2 Digit Number to convert

	Cmpi.b	#"0",1(a0)		-.
	Blt.s	FTC1Di2			 |_ Check 2nd digit is a number
	Cmpi.b	#"9",1(a0)		 |  If not, Check for 1 Dig #
	Ble.s	FTC2Di2			-'

FTC1Di2	Moveq	#1,d2			1 Dig to convert.

FTC2Di2	Bsr	Asc2Num			Ascii @ a0 » Num in d0
	Move.l	d0,d4			Place into d4.

	Cmp.l	d5,a0			End of input?
	Bge.s	BadInput

	Cmpi.b	#"]",(a0)+
	Bne.s	BadInput

;---> Now need to write <d3>.b into (a1)+, <d4> times <---------------------;
	Bsr	Restore_FT_Regs		Restore regs

	Add.l	d4,d0			Gunna write this many, update count.
	Bra.s	FTxCChJ
FTxCChL	Cmp.l	d6,a1			-.
	Blt.s	FTxNor4			 |- End of block = Allocate another
	Bsr	AlocOutBlock		-'
FTxNor4	Move.b	d3,(a1)+		Copy the char...
FTxCChJ	DBra	d4,FTxCChL		Copy the given number.
	Bra	FTxtSJm			Continue with original input.
*****************************************************************************
* BadInput: Generates & Sends error msg saying where the problem occured.   *
*****************************************************************************
BadInput
; InptAdr(a5) points to start of input.
; InptEnd(a5) points to end+1 of input area (DO NOT use d5!!!)
; FNaFTxt(a5) points to nullterm filename which input text was loaded from.
; a0 points to area of error.

	Moveq	#1,d0			Start on the 1st line.
	Move.l	d0,d1			at char 1.
	Move.l	d0,d3			#1 for quick adding.
	Moveq	#10,d2			<Return> for quick compares.
	Move.l	InptAdr(a5),a1
	Move.l	InptEnd(a5),d5

	Cmp.l	d5,a0			If error after end of file...
	Bge	Internal		...internal error.
	Cmp.l	a1,a0			If error before start of file...
	Blt	Internal		...internal error.
GetBadL	Cmp.l	a1,a0			Are we at the error pos. yet?
	Beq.s	GotBadI			YES = This part done then.
	Cmp.b	(a1)+,d2		Is this a return? (New Line).
	Beq.s	GBadRtn			YES = Branch
	Add.l	d3,d1			NO = At next char on this line.
	Bra.s	GetBadL			Check next char.
GBadRtn	Add.l	d3,d0			At next line.
	Move.l	d3,d1			At Char #1
	Bra.s	GetBadL			Check next char.

GotBadI	Move.l	d0,-(SP)		Preserve line count.
	Move.l	d1,-(SP)		Preserve char count.

	Lea	BIMsg1(pc),a0
	Move.l	#BIMsg1L,d3
	Bsr	CLIRite

	Move.l	FNaFTxt(a5),a0		Point to Filename for measuring...
	Bsr	NullLen			...its length
	Move.l	d0,d3			Length of Filename in d3.
	Move.l	FNaFTxt(a5),a0		Point to Filename to output to CLI.
	Bsr	CLIRite

	Lea	BIMsg2(pc),a0
	Move.l	#BIMsg2L,d3
	Bsr	CLIRite

	Move.l	(SP)+,d1		Restore Char count.
	Lea	StdBuff(a5),a1		Write into 80char error buffer.
	Move.l	a1,d5			Preserve a1
	Bsr	N2AAuto			Convert the number in d1 -> (a1)+.
	Move.l	a1,d3			Into d3 for write size.
	Sub.l	d5,d3			Now d3 = Chars written.
	Move.l	d5,a0			Adr to write from.
	Bsr	CLIRite

	Lea	BIMsg3(pc),a0
	Move.l	#BIMsg3L,d3
	Bsr	CLIRite

	Move.l	(SP)+,d1		Restore Line count.
	Lea	StdBuff(a5),a1		Write into 80char error buffer.
	Move.l	a1,d5			Preserve a1
	Bsr	N2AAuto			Convert the number in d1 -> (a1)+.
	Move.l	a1,d3			Into d3 for write size.
	Sub.l	d5,d3			Now d3 = Chars written.
	Move.l	d5,a0			Adr to write from.
	Bsr	CLIRite

	Lea	BIMsg4(pc),a0
	Move.l	#BIMsg4L,d3
	Bsr	CLIRite
	Bra	Finish
BIMsg1	Dc.b	10,'BAD INPUT in file "'
BIMsg1L	Equ	*-BIMsg1
BIMsg2	Dc.b	'"',10
	Dc.b	"Problem is around Col #"
BIMsg2L	Equ	*-BIMsg2
BIMsg3	Dc.b	", on Line #"
BIMsg3L	Equ	*-BIMsg3
BIMsg4	Dc.b	10,10
	Dc.b	"Note: Control Chars are *NOT* counted as newlines by SAmiLog...",10
	Dc.b	"----- However, they may be by your editor (e.g. CygnusEd).",10,10
BIMsg4L	Equ	*-BIMsg4
BICrdM	Dc.b	'"',10
	Dc.b	"You have not included the compulsory strings in your output!!",10,10
BICrdML	Equ	*-BICrdM
	Even
NoCreds	Lea	BIMsg1(pc),a0		'Bad input in file "'
	Moveq	#BIMsg1L,d3
	Bsr	CLIRite

	Move.l	FNaFTxt(a5),a0		Point to Filename for measuring...
	Bsr	NullLen			...its length
	Move.l	d0,d3			Length of Filename in d3.
	Move.l	FNaFTxt(a5),a0		Point to Filename to output.
	Bsr	CLIRite

	Lea	BICrdM(pc),a0		Rest of error message.
	Moveq	#BICrdML,d3
	Bsr	CLIRite
	Bra	Finish
