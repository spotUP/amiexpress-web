*****************************************************************************
*****************************************************************************
Setup	Movem.l	d0/a0,-(SP)		Preserve CommandLine Length/Adr
;===========================================================================;
; For residence, allocate memory for anything that'll change, and null it   ;
;===========================================================================;
	Move.l	#LENVARS,d0			-.  Allocate
	Move.l	#Memf_Public!Memf_Clear,d1	 |_ Memory for
	CALEXEC	AllocMem			-'  Variables.
	Move.l	d0,a5			Put variable/overlay address into A5
	Tst.l	d0			(Moves to a* don't set CCR).
	Beq	Fin_1			If Allocation failed, Exit Program
	Lea	NULLEND(a5),a0		-.
	Lea	Over00(pc),a1		 |  Copy Overlay
	Move.l	#(LENOVER/2)-1,d0	 |- Backings onto
OverPrL	Move.w	(a1)+,(a0)+		 |  Overlay Space (word moves)
	DBra	d0,OverPrL		-'
;===========================================================================;
	Movem.l	(SP)+,d0/a0		Restore CommandLine Length/Adr
;;;;;;;	Move.l	a0,CommAdd(a5)		Store Commandline Address
;;;;;;;	Move.l	d0,CommLen(a5)		Store Length of Commandline
	Move.l	a7,StarStk(a5)		Store Stack Pointer
	Addq.l	#4,StarStk(a5)		Compensate for this being a subrout.
	Lea	DosName(pc),a1		Get Address of Dos.Library Name
	Moveq	#36,d0			DOS v36 or Higher Required
	CALEXEC	OpenLib			Open Dos.Library (exec v36 req)
	Move.l	d0,DosBase(a5)		Store Address of Dos.Library
	Beq	Fin_2			If OpenLib failed, end Program
	CALLDOS	OutPut			-._ Get output Handle
	Move.l	d0,CLI_Hdl(a5)		-'  (CLI window or whatever)
;===========================================================================;
; Set PROGDIR: to the path in the ENV, or to a Default if ENV isn't found   ;
;===========================================================================;
EnvDir	Lea	DirVarN(pc),a0		Variable name = "SAmiLog_Path"
	Move.l	a0,d1
	Lea	StdBuff(a5),a0		Write into the buffer.
	Move.l	a0,d2
	Move.l	#StdBuffLen,d3		That is this many chars long.
	Moveq	#0,d4			Clear all flags
	CALLDOS	GetVar			Read the path into the buffer.
	Cmpi.l	#-1,d0			-._ If error while reading variable
	Beq.s	EnvDirN			-'  use the default path ("S:")
	Lea	StdBuff(a5),a0		Else, point to the new path...
	Bra.s	EnvDirY
DefPDir	Dc.b	"S:",0				Default PROGDIR:
DirVarN	Dc.b	"SAmiLog_Path",0		Path ENV Name.
	Even

EnvDirN	Lea	DefPDir(pc),a0		(Point to the default path)
EnvDirY	Move.l	a0,d1			Adr of Dir name into d1 for lock()
	Move.l	d1,FileNam(a5)		Setup filename too...
	Moveq	#SHARED_LOCK,d2		Read (Shared) Mode
	CALLDOS	Lock			Lock Dir
	Move.l	d0,d1			Lock into d1.
	Beq	Error
	Move.l	d0,Temp001(a5)		Store for later...
	IFNE	FilHead
	Lea	FilHead(a5),a0		260 bytes header memory (LW alligned)
	ELSE
	Lea	(a5),a0
	ENDC
	Move.l	a0,d2
	CALLDOS	Examine			Examine Dos Call.
	Tst.l	d0
	Beq	Error
	Tst.l	FH_DirEntryType(a5)	If >0 it's a dir(good). else file(bad)
	Bgt.s	DoPDir
	Move.l	#ERROR_OBJECT_WRONG_TYPE,d1	-.
	CALLDOS	SetIoErr			 |- If a file, Send Error Msg
	Bra	Error				-'
DoPDir	Move.l	Temp001(a5),d1		Lock on dir.
	CALLDOS	SetProgramDir		Set PROGDIR: to that dir.
;;;;;;;	DO *NOT* BEQ TO ERROR ROUTINE! Coz it will return the old PROGDIR:
;;;;;;;	lock, which would be NULL if run resident (this is valid). If you
;;;;;;;	can lock the thing, and it's a dir, it will work.
;;;;;;; ---------------------------------------------------------------------
;;;;;;;	The Lock we made on the directory (above) does *NOT* need unlocking
;;;;;;;	(as far as I know?, The autodocs don't say eitehr way, but you lose
;;;;;;; *NO* memory by not unlocking it, so I guess you don't have to!)
;;;;;;;	However, we MUST unlock the OLD ProgDir:
	Move.l	d0,d1			-._ UnLock() the OLD ProgDir
	CALLDOS	UnLock			-'  returned by SetProgramDir()
	Move.l	#0,FileNam(a5)		Clear filename too...
*****************************************************************************
	Lea	HeadTxt(pc),a0		-.
	Moveq	#HeadLen,d3		 |- Send Welcome Text.
	Bsr	CLIRite			-'
	Lea	Users_N_Def(pc),a0	-._ Default of
	Move.l	a0,Users_N(a5)		-'  10 users if option not given.
;;;;;;;	Setup any non-zero default values for switch options here.

	Bsr	RArgNor			Parse the commandline with ReadArgs

	Tst.l	Help_S(a5)		Have they asked for help on cmd line?
	Bne.s	AllDone			Yes = Send help and exit.
*****************************************************************************
	RTS

DosName	Dc.b	"dos.library",0
Users_N_Def	Dc.l	10
	Even
*****************************************************************************
*****************************************************************************
*****************************************************************************
*****************************************************************************
ADMsg	Dc.b	"All Operations Done.",10
ADMsgL	Equ	*-ADMsg
	Even
AllDone	BTst	#X1_AnyRout,Fil_F_1(a5)	Were ANY routines run?
	Beq	HelpTex			If not, send help text.

	Lea	ADMsg(pc),a0
	Moveq	#ADMsgL,d3
ADMsgSd	Bsr	CLIRite
*=- FINISH -=****************************************************************
* Close Everything Down, Return Memory Etc to System and End Program        *
*****************************************************************************
Finish
	IFD	TEST
	Lea	RTN_Msg(pc),a0
	Move.l	#RTN_Len,d3
	Bsr	CLIRite
	Bra.s	RTN_End
RTN_Msg	Dc.b	"*** Finish routine run. ***",10
RTN_Len	Equ	*-RTN_Msg
	Even
RTN_End
	ENDC
	BClr	#X1_Store,Fil_F_1(a5)	Is Storage file in memory?
	Beq.s	FinSkp1			Nope, leave it be.
	Lea	Store(pc),a0
	Move.l	a0,FileNam(a5)		Setup filename...
	Move.l	StorHdl(a5),d1		-._ Close
	CALLDOS	Close			-'  Storage File
	Tst.l	d0
	Beq	Error
	Move.l	#0,FileNam(a5)		Clear filename.
FinSkp1	Bsr.s	BigDAlo			Deallocate any files in memory.
	Bsr	FArgNor			Free the commandline related memory.
	BClr	#X1_Input,Fil_F_1(a5)	-.
	Beq.s	FinSkp2			 |
	Move.l	In_FSze(a5),d0		 |- DeAllocate "Input" file.
	Move.l	In_FAdr(a5),a1		 |
	CALEXEC	FreeMem			-'
FinSkp2	BClr	#X1_InList,Fil_F_1(a5)	-.
	Beq.s	FinSkp3			 |
	Move.l	ListSze(a5),d0		 |- DeAllocate Input file-list.
	Move.l	ListAdr(a5),a1		 |
	CALEXEC	FreeMem			-'
FinSkp3	Move.l	DosBase(a5),a1		-._ Close down
	CALEXEC	CloseLib		-'  dos.library
Fin_2	Move.l	StarStk(a5),a7		Ignore all Branches
	Move.l	#LENVARS,d0		-.
	Move.l	a5,a1			 |- Unallocate Variables/Overlays
	CALEXEC	FreeMem			-'
	Moveq	#RETURN_OK,d0		No Error return code to dos
Fin_1	RTS				End Program
*****************************************************************************
*****************************************************************************
*= BIG DE-ALLOCATE =*********************************************************
* Uses Fil_F_x(a5) to check which files are in mem and need De-Allocating   *
*****************************************************************************
* Normally, one should not put the FreeArgs() routine in here as this       *
* routine is not only called by Finish, but between seperate functions in   *
* a program. FreeArgs() should be done after BigDAlo in the finish routine. *
*****************************************************************************
BigDAlo	Move.l	#0,FileNam(a5)		Clear filename.
	Bsr	FilDAlo			Deallocate Default File +Use DOS.lib
	Bsr	FilClos			Close the Default File
	Bsr	FilULok			Unlock the Default File
BDA_0	BClr	#X2_Header,Fil_F_2(a5)	-.
	Beq.s	BDA_1			 |
	Move.l	HeadSze(a5),d0		 |- DeAllocate Header File.
	Move.l	HeadAdr(a5),a1		 |
	CALEXEC	FreeMem			-'
BDA_1	BClr	#X2_Tailer,Fil_F_2(a5)	-.
	Beq.s	BDA_2			 |
	Move.l	TailSze(a5),d0		 |- DeAllocate Tailer File.
	Move.l	TailAdr(a5),a1		 |
	CALEXEC	FreeMem			-'
BDA_2	Bra	DeAlocOutBlocks
;;;;;;;	RTS for us.
;;;;;;;	Storage File Does not need Deallocating coz it's in Var's memory.
;;;;;;;	Input file only deallocated in finish routine.
;;;;;;;	Input list only deallocated in finish routine.
;;;;;;;	FreeArgs() only done in finish routine.
*****************************************************************************
*****************************************************************************
*****************************************************************************
*****************************************************************************
*- ERROR MESSAGES -**********************************************************
* HELP TEXTS AND ERROR MESSAGES                                             *
*****************************************************************************
GenAbrt	Movem.l	d3/a0,-(SP)
	Lea	ErrHead(pc),a0		General header for Abort messages...
	Moveq	#ErrHedL,d3		Length of above.
	Bsr	CLIRite			Send it to them.
	Movem.l	(SP)+,d3/a0
	Bsr	CLIRite			Send msg from calling routine.
	Bra	Finish			End the program.
Internal Lea	InterM(pc),a0
	Moveq	#InterML,d3
	Bra.s	GenAbrt
InvCLog	Lea	InvCLM(pc),a0
	Moveq	#InvCLML,d3
	Bra.s	GenAbrt
NoVers	Lea	NoVersS(pc),a0
	Moveq	#NoVersL,d3
	Bra.s	GenAbrt
InvRND	Lea	InvRNDM(pc),a0
	Moveq	#InvRNDL,d3
	Bra.s	GenAbrt
InvList	Lea	InvLstM(pc),a0
	Move.l	#InvLstL,d3
	Bra.s	GenAbrt
Do0CNod	Lea	Do0CNoM(pc),a0
	Moveq	#Do0CNoL,d3
	Bra.s	GenAbrt
ErrHead	Dc.b	10,"S-AmiLog *ABORTED*",0	For Fault() DOS Call.
ErrHedL	Equ	(*-ErrHead)-1
InvCLM	Dc.b	": invalid Callerslog!",10
InvCLML	Equ	*-InvCLM
InterM	Dc.b	": internal error!!",10
InterML	Equ	*-InterM
Do0CNoM	Dc.b	": invalid node number!",10
Do0CNoL	Equ	*-Do0CNoM
NoVersS	Dc.b	": invalid Storage file!",10
NoVersL	Equ	*-NoVersS
InvRNDM	Dc.b	": invalid Random-Lines file!",10
InvRNDL	Equ	*-InvRNDM
InvLstM	Dc.b	": invalid Output file-list!",10
InvLstL	Equ	*-InvLstM
HeadTxt	Dc.b	10,155,"32;1mSuper-AmiLog "
	VERSION
	Dc.b	" ",155,"0m[",155,"33m"
	IFND	USUM
	Dc.b	"REL-"
	RELNUMB
	Dc.b	" "
	BETANUM
	ENDC
	IFD	USUM
	Dc.b	"RELEASE "
	RELNUMBER
	ENDC
	Dc.b	155,"0m] ",155,"32m- ",155,"33m©1992-4 P0T-NOoDLE of Gods'Gift/ANTHR0X",155,"0m",10
HeadLen	Equ	*-HeadTxt
Help_1	Dc.b	155,"0mLast Callers & System Stats util for AmiExpress, SigmaExpress, and Swift",10
	Dc.b	10
	Dc.b	"ReadArgs() Template:",10
Help_1L	Equ	*-Help_1
Help_2	Dc.b	10,10
	Dc.b	"Help      Show this help text.         OutANSI   Create ANSI output.",10
	Dc.b	"                                       OutNoANSI Create Non-ANSI output.",10
	Dc.b	"Clear     Clear Storage-File.          Users     Nº users to output.",10
	Dc.b	"                                       Design    External SADeL design.",10
	Dc.b	"Update    Update for the given node.   IntType   Type of internal design.",10
	Dc.b	"NoSysop   Ignore calls by the sysop.   Option    Options for the design.",10
	Dc.b	"MClog     Create the MiniCallerslog.   Top       Header for output.",10
	Dc.b	"                                       Bottom    Tailer for output.",10
	Dc.b	"StripMCL  Strip MClog, except X days.  (No)ANSITop / (No)ANSIBottom.",10
	Dc.b	10
	Dc.b	"- Read the SAmiLog documentation for full descriptions and examples!",10
	Dc.b	"- External SADeL files should have their own docs on extra OPTIONs.",10
	Dc.b	10
Help_2L	Equ	*-Help_2
	Even
*****************************************************************************
*****************************************************************************
HelpTex	Lea	Help_1(pc),a0
	Moveq	#Help_1L,d3
	Bsr	CLIRite

	Lea	RDA_Template(pc),a0
	Move.l	#RDA_Temp_Len,d3
	Bsr	CLIRite

	Lea	Help_2(pc),a0
	Move.l	#Help_2L,d3
	Bsr	CLIRite

	Bra	Finish
*****************************************************************************
*****************************************************************************
*****************************************************************************
*****************************************************************************
*- LOAD STORAGE -************************************************************
* Load Storage file into auto-alloced memory, if not there already.         *
*****************************************************************************
LoadSto	BTst	#X1_Store,Fil_F_1(a5)	Is Storage file in memory?
	Bne.s	SKIPPER			Yes = Don't load it again!

STOMain	BSet	#SF1_NWGetS,STD_F_1(a5)	If set, we shoud get the filesize.
	Lea	Store(pc),a0		-.
	Move.l	#Mode_Old,Temp002(a5)	 |- Open file for writting.
	Bsr	NWrNoNu			-'  (Well, with semi-EXCL access at least)
	Move.l	FileHdl(a5),StorHdl(a5)
	BClr	#SF1_Open,STD_F_1(a5)	No longer standard file...
	BSet	#X1_Store,Fil_F_1(a5)	Storage File Has Been Loaded (is open).
;;;;;;; Ensures it's not loaded again, and it's Closed at Finish.
;;;;;;;	We have left it open on purpose.

	Cmpi.l	#S_Size,FileSze(a5)	Is The config file correct # bytes?
	Bne	NoVers			No=SAL Storage Format v0.03!

	Lea	Store(pc),a0
	Move.l	a0,FileNam(a5)		Setup filename for error calls...

	Move.l	StorHdl(a5),d1		Storage File Handle. -> d1 for Read
	Lea	StorFil(a5),a0		Storage File Memory.
	Move.l	a0,d2
	Move.l	#S_Size,d3		Storage File Size.
	CALLDOS	Read			Read File into Pre-Auto-Aloced Mem.
	Cmpi.l	#-1,d0
	Beq	Error
;===========================================================================;
	Lea	StorFil(a5),a0		-.
	Lea	S_Vers(pc),a2		 |_ Search for correct version
	Cmpm.l	(a0)+,(a2)+
	Bne	NoVers
	Cmpm.l	(a0)+,(a2)+
	Bne	NoVers
SKIPPER	Move.l	#0,FileNam(a5)		Clear filename.
	RTS
	IFD	TEST
Store	Dc.b	"TEMP:SAmiLog.Store",0
	ELSE
Store	Dc.b	"PROGDIR:SAmiLog.Store",0
	ENDC
	Even
*****************************************************************************
*****************************************************************************
*****************************************************************************
*****************************************************************************
